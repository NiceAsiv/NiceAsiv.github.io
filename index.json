[{"content":"Helloworld world is beautiful\n二级标题 三级标题 四级标题 五级标题 六级标题 公式测试 $$ \\sum_{i=1}^n a_i=0 $$\ngraph LR A[方形] --\u003eB(圆角) B --\u003e C{条件a} C --\u003e|a=1| D[结果1] C --\u003e|a=2| E[结果2] F[横向流程图] graph TD A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[纵向流程图] ","permalink":"https://niceasiv.cn/posts/helloworld/","summary":"Helloworld world is beautiful\n二级标题 三级标题 四级标题 五级标题 六级标题 公式测试 $$ \\sum_{i=1}^n a_i=0 $$\ngraph LR A[方形] --\u003eB(圆角) B --\u003e C{条件a} C --\u003e|a=1| D[结果1] C --\u003e|a=2| E[结果2] F[横向流程图] graph TD A[方形] --\u0026gt;B(圆角) B --\u0026gt; C{条件a} C --\u0026gt;|a=1| D[结果1] C --\u0026gt;|a=2| E[结果2] F[纵向流程图] ","title":"Helloworld"},{"content":" 参考课件 chap06.pdf 中“通过修改PE装载DLL”一节的内容，以及课本第 5.5节的 内容，实现对notepad.exe（修復並下載Notepad.exe）的修改，使得修改后的 notepad.exe 在双击运行时，能够自动隐式装载 MyDll3.dll，并进而 将一个网页下载到本地index.html 文件。\n本上机作业的目的是让大家深入理解 PE 文件中的导入表、导入地址表等关键结构及相关的功能。\n本实验所使用的notepad.exe 是 Windows 7系统（最好32位版）中的可执行程序，MyDll3.dll 也仅保证在 Windows 7下能正常工作，因此，建议在 Windows 7环境（可预先安装虚拟机）下进行修改。请在虚拟机中禁用所有杀毒软件，确保修改过程不会受到杀毒软件的干扰。保证虚拟机能联网，以便DLL装载后的网页下载动作能正常完成。 下载notepad.exe可能与课本中所描述的notepad.exe版本不一致，应主要参考课件中的修改流程。 使用PEview分析PE文件，使用HxD编辑器修改PE文件。 直接使用本书所附代码编译生成 MyDll3.dll。 PE文件静态注入 这里因为notepad一直注入不成功，换了个win7版本也不行，好像是安全策略的原因，就只好找另外一个textview.exe进行注入\n代码是李承远老师的逆向工程核心原理当中的\n// dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \u0026#34;pch.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;windows.h\u0026#34; #include \u0026#34;shlobj.h\u0026#34; #include \u0026#34;Wininet.h\u0026#34; #include \u0026#34;tchar.h\u0026#34; #pragma comment(lib, \u0026#34;Wininet.lib\u0026#34;) #define DEF_BUF_SIZE (4096) #define DEF_URL L\u0026#34;http://www.baidu.com/index.html\u0026#34; #define DEF_INDEX_FILE L\u0026#34;index.html\u0026#34; HWND g_hWnd = NULL; #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // 导出函数，但是没有任何功能，仅仅保持dll文件的形式上完整。 __declspec(dllexport) void dummy() { return; } #ifdef __cplusplus } #endif //DownloadURL 下载 szURL 中指定网站的文件，并将其保存在 szFile 目录。 BOOL DownloadURL(LPCTSTR szURL, LPCTSTR szFile) { BOOL bRet = FALSE; HINTERNET hInternet = NULL, hURL = NULL; BYTE pBuf[DEF_BUF_SIZE] = { 0, }; DWORD dwBytesRead = 0; FILE* pFile = NULL; errno_t err = 0; hInternet = InternetOpen(L\u0026#34;ReverseCore\u0026#34;, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0); if (NULL == hInternet) { OutputDebugString(L\u0026#34;InternetOpen() failed!\u0026#34;); return FALSE; } hURL = InternetOpenUrl(hInternet, szURL, NULL, 0, INTERNET_FLAG_RELOAD, 0); if (NULL == hURL) { OutputDebugString(L\u0026#34;InternetOpenUrl() failed!\u0026#34;); goto _DownloadURL_EXIT; } if (err = _tfopen_s(\u0026amp;pFile, szFile, L\u0026#34;wt\u0026#34;)) { OutputDebugString(L\u0026#34;fopen() failed!\u0026#34;); goto _DownloadURL_EXIT; } while (InternetReadFile(hURL, pBuf, DEF_BUF_SIZE, \u0026amp;dwBytesRead)) { if (!dwBytesRead) break; fwrite(pBuf, dwBytesRead, 1, pFile); } bRet = TRUE; _DownloadURL_EXIT: if (pFile) fclose(pFile); if (hURL) InternetCloseHandle(hURL); if (hInternet) InternetCloseHandle(hInternet); return bRet; } BOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam) { DWORD dwPID = 0; GetWindowThreadProcessId(hWnd, \u0026amp;dwPID); if (dwPID == (DWORD)lParam) { g_hWnd = hWnd; return FALSE; } return TRUE; } HWND GetWindowHandleFromPID(DWORD dwPID) { EnumWindows(EnumWindowsProc, dwPID); return g_hWnd; } //DropFile 函数将下载的 index.html 文件 拖到 TextView_Path.exe进程并显示其内容。 BOOL DropFile(LPCTSTR wcsFile) { HWND hWnd = NULL; DWORD dwBufSize = 0; BYTE* pBuf = NULL; DROPFILES* pDrop = NULL; char szFile[MAX_PATH] = { 0, }; HANDLE hMem = 0; WideCharToMultiByte(CP_ACP, 0, wcsFile, -1, szFile, MAX_PATH, NULL, NULL); dwBufSize = sizeof(DROPFILES) + strlen(szFile) + 1; if (!(hMem = GlobalAlloc(GMEM_ZEROINIT, dwBufSize))) { OutputDebugString(L\u0026#34;GlobalAlloc() failed!!!\u0026#34;); return FALSE; } pBuf = (LPBYTE)GlobalLock(hMem); pDrop = (DROPFILES*)pBuf; pDrop-\u0026gt;pFiles = sizeof(DROPFILES); strcpy_s((char*)(pBuf + sizeof(DROPFILES)), strlen(szFile) + 1, szFile); GlobalUnlock(hMem); if (!(hWnd = GetWindowHandleFromPID(GetCurrentProcessId()))) { OutputDebugString(L\u0026#34;GetWndHandleFromPID() failed!!!\u0026#34;); return FALSE; } PostMessage(hWnd, WM_DROPFILES, (WPARAM)pBuf, NULL); return TRUE; } DWORD WINAPI ThreadProc(LPVOID lParam) { TCHAR szPath[MAX_PATH] = { 0, }; TCHAR* p = NULL; OutputDebugString(L\u0026#34;ThreadProc() start...\u0026#34;); GetModuleFileName(NULL, szPath, sizeof(szPath)); if (p = _tcsrchr(szPath, L\u0026#39;\\\\\u0026#39;)) { _tcscpy_s(p + 1, wcslen(DEF_INDEX_FILE) + 1, DEF_INDEX_FILE); OutputDebugString(L\u0026#34;DownloadURL()\u0026#34;); if (DownloadURL(DEF_URL, szPath)) { OutputDebugString(L\u0026#34;DropFlie()\u0026#34;); DropFile(szPath); } } OutputDebugString(L\u0026#34;ThreadProc() end...\u0026#34;); return 0; } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: CloseHandle(CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL)); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } dummmy()函数实际是dll文件向外部提供服务的导出函数，但正如所见,它没有任何功能。既然如此，为何还要将其导出呢?这是为了保持形式上的完整性，mydll3.dll能够顺利添加到notepad_patch.exe文件的导入表。\n生成的myhack3.dll\n查看IDT是否有足够空间 我们从Image_Optional_Header的IMPORT Table得到结构体数组的RVA和Size\n通过查看image_section_header，发现RVA84CC处于rdata区域\n计算偏移\n0x6000-0x5200 = 0xE00\n文件偏移=即0x84CC -0xE00 = 0x76CC\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // RVA 指向INT (PIMAGE_THUNK_DATA) }; DWORD TimeDateStamp; DWORD ForwarderChain; // -1 if no forwarders DWORD Name; //dll 名称 DWORD FirstThunk; //指向引入函数真实地址单元处的RVA IAT } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 也可以将PEview调成文件偏移视图查看，可以看到文件偏移确实是0x76CC\n然后我们使用010 editor打开可以发现64Bytes的空间，有五个IDT结构体，最后一个为NULL,在我们的IDT之后紧贴着其它数据，我们没有足够的空间来添加一个0x14字节的结构体进去\n移动IDT\n从节区头信息可以得到，其内存virtual Size与文件的大小Size of Raw Data是不一样的\n.rdata 节区在磁盘文件中的大小为 2E00,而文件执行后被加载到内存时，程序实际使用的数据大小（映射大小）仅为 2C56 ，剩余未被使用的区域大小为 1AA （2E00 - 2C56)足够放下(0x14 * 6 = 0x78)字节的数据\n可以先从0x8C80开始存放我们的IDT(转化为文件偏移为0x7E80)(新IDT: 0x7E80到(0x7E80+0x78)）\nTextView.exe 文件中，导入表的 RVA 值为 84CC 。接下来，将导入表的 RVA 值更改为新 IDT 的 RVA 值 8C80,在 Size 原值64字节的基础上再加 14字节（IID 结构体的大小），修改为78字节\n修改后导入表位于 RVA: 8C80(RAW : 7E80)地址处\n先使用010 Editor完全复制原IDT（RAW:76CC~772F）,然后覆盖到IDT的新位置(RAW:7E80)\n在7ED0处写入IID\n然后在新IDT尾部(RAW:7ED0)添加与mydll3对应的IID\n转到 7F00 地址处，输入相应值\n3.修改 IAT 节区的属性值\n向原属性（ChAracteristics）40000040 添加 IMAGE_SCN_MEM_WRITE(80000000)属性值\n也就是C0000040\n使用 PEView 工具打开修改后的 TextView.exe 文件，查看其 IDT，发现已经装载上了myhack3.dll\n点开，我们发现它成功下载了百度某个cdn下的index.html，并展示在文字框中\n参考文献 [[原创]通过修改PE加载DLL]https://bbs.pediy.com/thread-267045-1.htm\n[通过修改PE文件的方式导入DLL]https://blog.csdn.net/fanxiaoyao1/article/details/125379489\n李承远 逆向工程核心原理\n","permalink":"https://niceasiv.cn/posts/pe_dll/","summary":"参考课件 chap06.pdf 中“通过修改PE装载DLL”一节的内容，以及课本第 5.5节的 内容，实现对notepad.exe（修復並下載Notepad.exe）的修改，使得修改后的 notepad.exe 在双击运行时，能够自动隐式装载 MyDll3.dll，并进而 将一个网页下载到本地index.html 文件。\n本上机作业的目的是让大家深入理解 PE 文件中的导入表、导入地址表等关键结构及相关的功能。\n本实验所使用的notepad.exe 是 Windows 7系统（最好32位版）中的可执行程序，MyDll3.dll 也仅保证在 Windows 7下能正常工作，因此，建议在 Windows 7环境（可预先安装虚拟机）下进行修改。请在虚拟机中禁用所有杀毒软件，确保修改过程不会受到杀毒软件的干扰。保证虚拟机能联网，以便DLL装载后的网页下载动作能正常完成。 下载notepad.exe可能与课本中所描述的notepad.exe版本不一致，应主要参考课件中的修改流程。 使用PEview分析PE文件，使用HxD编辑器修改PE文件。 直接使用本书所附代码编译生成 MyDll3.dll。 PE文件静态注入 这里因为notepad一直注入不成功，换了个win7版本也不行，好像是安全策略的原因，就只好找另外一个textview.exe进行注入\n代码是李承远老师的逆向工程核心原理当中的\n// dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \u0026#34;pch.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;windows.h\u0026#34; #include \u0026#34;shlobj.h\u0026#34; #include \u0026#34;Wininet.h\u0026#34; #include \u0026#34;tchar.h\u0026#34; #pragma comment(lib, \u0026#34;Wininet.lib\u0026#34;) #define DEF_BUF_SIZE (4096) #define DEF_URL L\u0026#34;http://www.baidu.com/index.html\u0026#34; #define DEF_INDEX_FILE L\u0026#34;index.html\u0026#34; HWND g_hWnd = NULL; #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // 导出函数，但是没有任何功能，仅仅保持dll文件的形式上完整。 __declspec(dllexport) void dummy() { return; } #ifdef __cplusplus } #endif //DownloadURL 下载 szURL 中指定网站的文件，并将其保存在 szFile 目录。 BOOL DownloadURL(LPCTSTR szURL, LPCTSTR szFile) { BOOL bRet = FALSE; HINTERNET hInternet = NULL, hURL = NULL; BYTE pBuf[DEF_BUF_SIZE] = { 0, }; DWORD dwBytesRead = 0; FILE* pFile = NULL; errno_t err = 0; hInternet = InternetOpen(L\u0026#34;ReverseCore\u0026#34;, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0); if (NULL == hInternet) { OutputDebugString(L\u0026#34;InternetOpen() failed!\u0026#34;); return FALSE; } hURL = InternetOpenUrl(hInternet, szURL, NULL, 0, INTERNET_FLAG_RELOAD, 0); if (NULL == hURL) { OutputDebugString(L\u0026#34;InternetOpenUrl() failed!","title":"通过修改 PE 装载 DLL 实验"},{"content":"题目摘要 赛题名称： RSA 加密体制破译 赛题描述 RSA密码算法是使用最为广泛的公钥密码体制。该体制简单且易于实现，只需要选择5个参数即可（两个素数$𝑝$和$𝑞$、模数$𝑁=𝑝𝑞$、加密指数$𝑒$和解密指数$𝑑$。设𝑚为待加密消息RSA体制破译相当于已知$𝑚^𝑒$ $mod$ $𝑁$能否还原𝑚的数论问题。目前模数规模为1024比特的RSA算法一般情况下是安全的，但是如果参数选取不当，同样存在被破译的可能。有人制作了一个RSA加解密软件采用的RSA体制的参数特点描述见密码背景部分）。\n已知该软件发送某个明文的所有参数和加密过程的全部数据（加密案例文件详见附件3-1。Alice使用该软件发送了一个通关密语，且所有加密数据已经被截获，请问能否仅从加密数据恢复该通关密语及RSA体制参数？如能请给出原文和参数，如不能请给出已恢复部分并说明剩余部分不能恢复的理由？\n加密过程 原始明文 This is a test of my RSA system. Frame0\nA5F51EB02EA9C0CC9B96926A08A761FE3E7CDB6E5B348DBEAEC761DBCFCDB15A6C76F8EE08196008AE60E396D7E228C6DAFC3CC1127F16EC87576B89C151F20F99098621FD46872BC92CDA8C915B758E5C0CACB994F55B8705B938126E08589E2502A7B9019C9A62E82392E8449E00CFC7DA17B8CDE92F9516CE9A2009F42DD900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100019726C82FED1E6CD58DE825528AE5634653C9921CAE02AFF7325F20D6E7085B7C8E3DC78D7518A78A8BC7D07E2E837083324579510851827794AE3D1FB9BAB360B1413A8F171A83804CEA73DFBC1248139BB27EB7D5BAD724AD8B08F51888B90562AF950725ACDD698F817AE62746CEA09479A191A6552B0116830355C68D0F61 Frame1\nA5F51EB02EA9C0CC9B96926A08A761FE3E7CDB6E5B348DBEAEC761DBCFCDB15A6C76F8EE08196008AE60E396D7E228C6DAFC3CC1127F16EC87576B89C151F20F99098621FD46872BC92CDA8C915B758E5C0CACB994F55B8705B938126E08589E2502A7B9019C9A62E82392E8449E00CFC7DA17B8CDE92F9516CE9A2009F42DD90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001789018FDB800AD59A54D27A77F280515BB3BFAB1CD75CB0A255A116D4A44849459FD887FF091F87C0B3E6305F019700E4E4CB3646D1DF276DFB87C4F64245F77377508EC6A796236F8ABB125023D3F4B898F55E3342D0A852193AF890990EA82F12FC85917BF132F2A58C449648D6E934B24E80307AB092DB18110D77BBA0F8E Frame2\nBA645145D9DE58B0FFA6FC4624A2815092D2A2DC405E7A2515F985727D3C52F479A4D04694568CA9B08391BE79BD122808CF6034AB7251088687BFF5916A4F4723FE1372DCF9B069CAB269A9F8F47CB50078D3279B9452C9B3B65A07B49C793783EDB8EB8D8F1A220D9EFED33147483103A2551A96932738255493F13B5119530000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001534810A0D1B2F6FB257DC3BBDA30AA76157B89038E52D05EE1E5DB06C2D79FAE84892950EF5FD8ADC4F241C3741AD7C97002902C8CA4D96574F28EDCEF3BEF15303335FA8D250102B4EE77E3B405E30F6B81E92403A8881285B65F29668E05B9CD6AC44FC1CD193CF4A5811A2649BE0EDEFBA91FA7143266286C5EC6EE8077D6 Frame3\nBA645145D9DE58B0FFA6FC4624A2815092D2A2DC405E7A2515F985727D3C52F479A4D04694568CA9B08391BE79BD122808CF6034AB7251088687BFF5916A4F4723FE1372DCF9B069CAB269A9F8F47CB50078D3279B9452C9B3B65A07B49C793783EDB8EB8D8F1A220D9EFED33147483103A2551A96932738255493F13B51195300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100018805A937DABF25FE760F9F398C7D9D5955EF7468FEC89119F8DD69874FB009AB2C424BD6A8E85401C4CD130B48D0490586DFBD81C8154EDCEFC3AFC4F80338432197EB059AB54CF109B231416FB65E2F9BE4F01D455E25486D8E155A5874E8A910E8C65F73ACD953D316B35A148D5AC5834D86F66AD415EBA38AD3908B32780A 2.过程及参数\nRSA 密码算法描述如下，包含体制参数选取和加解密过程。\n1）RSA 体制参数选取\n​ Step1.每个使用者，任意选择两个大素数$𝑝$和$𝑞$，并求出其乘积$𝑁=𝑝𝑞$。\n​ Step2.令$𝜑(𝑁)=(𝑝−1)(𝑞−1)$选择整数$𝑒$，使得$GCD(𝑒,𝜑(𝑁))=1$，并求出$𝑒$模 $𝜑(𝑁)$的逆元$𝑑$，即$𝑒𝑑≡1 mod (𝜑(𝑁))$\n​ Step3.将数对$(𝑒,𝑁)$公布为公钥，$𝑑$保存为私钥。\n2）加解密过程\n​ Bob欲传递明文𝑚给 Alice，则Bob首先由公开途径找出 Alice 的公钥 $(𝑒,𝑁)$，Bob 计算加密的信息$𝑐$为:$𝑐 ≡ 𝑚^𝑒$ $mod$ $𝑁$。\n​ Bob 将密文$𝑐$传送给 Alice。 随后 Alice 利用自己的私钥$𝑑$解密： ​ $𝑐^e ≡ (𝑚^𝑒)^𝑑 ≡ 𝑚^{𝑒𝑑}≡ 𝑚\\space mod\\space 𝑁$\nAlice 使用的 RSA 密码体制有以下事项需要说明：\n​\t1）模数𝑁=𝑝𝑞规模为1024比特，其中𝑝，𝑞为素数；\n​\t2）素数𝑝由某一随机数发生器生成；\n​\t3）素数𝑞可以随机选择，也可以由2）中的随机数发生器产生；\n​\t4）可以对文本加密，每次加密最多8个明文字符；\n​\t5）明文超过8个字符时，对明文分片，每个分片不超过8个字符；\n​\t6）分片==明文填充为512比特消息后再进行加密，填充规则为高位添加64比特标志位，随后加上32比特通信序号==，再添加若干个0，最后64比特为明文分片字符对应的ASCII码（**注：填充方式参见加密案例，但注意每次通信的标志位可能变化）\n​\t7）分片加密后发送一个加密帧数据，帧数据文件名称为FrameXX，其中XX表示接收序号，该序号不一定等于通信序号；\n​\t8）帧数据的数据格式如下，其中数据都是16进制表示，结构如下==1024bit模数N | 1024bit加密指数e | 1024bit密文== $m^e\\space mod \\space N$。\n​\t9）由于Alice初次使用该软件，可能会重复发送某一明文分片。\n符号说明： n 模数、p 素数、q素数、e加密指数、d 解密指数、m 明文分片、c 密文分片、“0X”十六进制数据表示\n明文： \u0026ldquo;This is a test of my RSA system.\u0026ldquo;将其分割为4个8字符长度消息(注意：空格也是一个字符)\nThis is 该8字符对应的ASCII为\t54\t68\t69\t73\t20\t69\t73\t20\t将其视为64比特整数为==\u0026gt;\t0X5468697320697320 a test o\t该8字符对应的ASCII为\t61\t20\t74\t65\t73\t74\t20\t6F\t将其视为64比特整数为==\u0026gt;\t0X612074657374206F f my RSA\t该8字符对应的ASCII为\t66\t20\t6D\t79\t20\t52\t53\t41\t将其视为64比特整数为==\u0026gt;\t0X66206D7920525341 system.\t该8字符对应的ASCII为\t20\t73\t79\t73\t74\t65\t6D\t2E\t将其视为64比特整数为==\u0026gt;\t0X2073797374656D2E 选择前缀为0xFFFFFFFFFFFFFFFF,再添加通信序号和若干个0，最终填充后的4条消息依次为\n0xFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005468697320697320 0xFFFFFFFFFFFFFFFF000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000612074657374206F 0xFFFFFFFFFFFFFFFF00000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066206D7920525341 0xFFFFFFFFFFFFFFFF0000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000002073797374656D2E 第0个明文分片参数及加密结果\np= 0XC60C5F1B997ED8A5E340023F33D2E269CFB423A3CF66B46D3F686747403A92B1265CB12B9A4E0135B890254F31A2C3F96A0427B39A36DEFDEEB85C57A80A9641 q= 0XD684DA331AB6157DA338B6D7B08AB4C1B72C29BB7F9EF445466056DFDBF29809C4D4A2435986A40DE688AFE7CC5A5C519F7C63CB486E44D523B0E1EF21C22199 n= 0XA5F51EB02EA9C0CC9B96926A08A761FE3E7CDB6E5B348DBEAEC761DBCFCDB15A6C76F8EE08196008AE60E396D7E228C6DAFC3CC1127F16EC87576B89C151F20F99098621FD46872BC92CDA8C915B758E5C0CACB994F55B8705B938126E08589E2502A7B9019C9A62E82392E8449E00CFC7DA17B8CDE92F9516CE9A2009F42DD9 e= 0X10001 d= 0X4C5340AAECBB1BB5BE74F09F9D9D45BF4583ECF38334D75FF44834A4809CEC4D57071C9374DC1EC3BF574634B0D30DC7EF1D04E0131EAA2F5C4B8364D6A95676C23F9DADAAB4523A6F5B22EC5904650BF558B3FDF39E3B13EA4771FB1D297DA03C8E1E82F4759B31A9492C56E4D1C690A66ECEC430849A17C027D1A7480F1E01 m= 0XFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005468697320697320 c= 0X9726C82FED1E6CD58DE825528AE5634653C9921CAE02AFF7325F20D6E7085B7C8E3DC78D7518A78A8BC7D07E2E837083324579510851827794AE3D1FB9BAB360B1413A8F171A83804CEA73DFBC1248139BB27EB7D5BAD724AD8B08F51888B90562AF950725ACDD698F817AE62746CEA09479A191A6552B0116830355C68D0F61 第1个明文分片参数及加密结果\np= 0XC60C5F1B997ED8A5E340023F33D2E269CFB423A3CF66B46D3F686747403A92B1265CB12B9A4E0135B890254F31A2C3F96A0427B39A36DEFDEEB85C57A80A9641 q= 0XD684DA331AB6157DA338B6D7B08AB4C1B72C29BB7F9EF445466056DFDBF29809C4D4A2435986A40DE688AFE7CC5A5C519F7C63CB486E44D523B0E1EF21C22199 n= 0XA5F51EB02EA9C0CC9B96926A08A761FE3E7CDB6E5B348DBEAEC761DBCFCDB15A6C76F8EE08196008AE60E396D7E228C6DAFC3CC1127F16EC87576B89C151F20F99098621FD46872BC92CDA8C915B758E5C0CACB994F55B8705B938126E08589E2502A7B9019C9A62E82392E8449E00CFC7DA17B8CDE92F9516CE9A2009F42DD9 e= 0X10001 d= 0X4C5340AAECBB1BB5BE74F09F9D9D45BF4583ECF38334D75FF44834A4809CEC4D57071C9374DC1EC3BF574634B0D30DC7EF1D04E0131EAA2F5C4B8364D6A95676C23F9DADAAB4523A6F5B22EC5904650BF558B3FDF39E3B13EA4771FB1D297DA03C8E1E82F4759B31A9492C56E4D1C690A66ECEC430849A17C027D1A7480F1E01 m= 0XFFFFFFFFFFFFFFFF000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000612074657374206F c= 0X789018FDB800AD59A54D27A77F280515BB3BFAB1CD75CB0A255A116D4A44849459FD887FF091F87C0B3E6305F019700E4E4CB3646D1DF276DFB87C4F64245F77377508EC6A796236F8ABB125023D3F4B898F55E3342D0A852193AF890990EA82F12FC85917BF132F2A58C449648D6E934B24E80307AB092DB18110D77BBA0F8E 第2个明文分片参数及加密结果\np= 0XD502B3D96C648A9393966CDD37188D37576AA221290C861B347ED7A57640993F7ED2D16992B42AA3CA66936D3268DE47EB3A61B1495C982BF54EC0350B907C4F3CA272F9ED04EEB355367DFDA1B89357130A25411DAC4E3B8A1EECC594E0435F0E7298897B54D6C334062C8D8508AC67CEDAECD1A5FCA84BF2EE5D q= 0XE00258CB6F n= 0XBA645145D9DE58B0FFA6FC4624A2815092D2A2DC405E7A2515F985727D3C52F479A4D04694568CA9B08391BE79BD122808CF6034AB7251088687BFF5916A4F4723FE1372DCF9B069CAB269A9F8F47CB50078D3279B9452C9B3B65A07B49C793783EDB8EB8D8F1A220D9EFED33147483103A2551A96932738255493F13B511953 e= 0X10001 d= 0X524EB244F1CE59966C273B91AC40B620CFB55BA2030E871F01147E11844888B6224C5D4DE14551DFDB93C984DAD94A4359643B247ED6CC7DE774A15440D525E26FE9CF4328DBEF2AAA8E402922596F1C23B8F117C018870777434C93B68F1028295DFA6E69FA8E00FFC4EFEF747C348EDBC99C529B7C3B649813647FF90A8261 m= 0XFFFFFFFFFFFFFFFF00000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066206D7920525341 c= 0X534810A0D1B2F6FB257DC3BBDA30AA76157B89038E52D05EE1E5DB06C2D79FAE84892950EF5FD8ADC4F241C3741AD7C97002902C8CA4D96574F28EDCEF3BEF15303335FA8D250102B4EE77E3B405E30F6B81E92403A8881285B65F29668E05B9CD6AC44FC1CD193CF4A5811A2649BE0EDEFBA91FA7143266286C5EC6EE8077D6 第3个明文分片参数及加密结果\np= 0XD502B3D96C648A9393966CDD37188D37576AA221290C861B347ED7A57640993F7ED2D16992B42AA3CA66936D3268DE47EB3A61B1495C982BF54EC0350B907C4F3CA272F9ED04EEB355367DFDA1B89357130A25411DAC4E3B8A1EECC594E0435F0E7298897B54D6C334062C8D8508AC67CEDAECD1A5FCA84BF2EE5D q= 0XE00258CB6F n= 0XBA645145D9DE58B0FFA6FC4624A2815092D2A2DC405E7A2515F985727D3C52F479A4D04694568CA9B08391BE79BD122808CF6034AB7251088687BFF5916A4F4723FE1372DCF9B069CAB269A9F8F47CB50078D3279B9452C9B3B65A07B49C793783EDB8EB8D8F1A220D9EFED33147483103A2551A96932738255493F13B511953 e= 0X10001 d= 0X524EB244F1CE59966C273B91AC40B620CFB55BA2030E871F01147E11844888B6224C5D4DE14551DFDB93C984DAD94A4359643B247ED6CC7DE774A15440D525E26FE9CF4328DBEF2AAA8E402922596F1C23B8F117C018870777434C93B68F1028295DFA6E69FA8E00FFC4EFEF747C348EDBC99C529B7C3B649813647FF90A8261 m= 0XFFFFFFFFFFFFFFFF0000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000002073797374656D2E c= 0X8805A937DABF25FE760F9F398C7D9D5955EF7468FEC89119F8DD69874FB009AB2C424BD6A8E85401C4CD130B48D0490586DFBD81C8154EDCEFC3AFC4F80338432197EB059AB54CF109B231416FB65E2F9BE4F01D455E25486D8E155A5874E8A910E8C65F73ACD953D316B35A148D5AC5834D86F66AD415EBA38AD3908B32780A 密文结构解析 提取传送帧的信息\nn=[]#模数集合 e=[]#公钥指数集合 c=[]#密文集合 m={}#明文集合 # Path: code\\main.py sloved=[]#已解密的密文集合 filename=[\u0026#39;RSA\\data\\Frame\u0026#39;+str(i) for i in range(0,21)]#文件名集合 # print(filename) for i in range(0,21): f=open(filename[i],\u0026#39;r\u0026#39;) data=f.read() #str-\u0026gt;hex-\u0026gt;int n.append(int(data[:256],16)) e.append(int(data[256:512],16)) c.append(int(data[512:],16)) #输出e的值 for i in range(0,21): print(\u0026#39;e[\u0026#39;+str(i)+\u0026#39;]=\u0026#39;+str(e[i])) #输出n的值 for i in range(0,21): print(\u0026#39;n[\u0026#39;+str(i)+\u0026#39;]=\u0026#39;+str(n[i])) #输出c的 for i in range(0,21): print(\u0026#39;c[\u0026#39;+str(i)+\u0026#39;]=\u0026#39;+str(c[i])) Output\ne[0]=46786465362686334917265996843779843233606992585424976481745055335468678697948774988450305612127967926533923268260412557000125153569622340353246096040604284883505587337829322949633637609180797447754513992039018904786537115087888005528547900640339270052628915440787357271345416818313808448127098885767015748889 e[1]=65537 e[2]=65537 e[3]=5 e[4]=152206992575706893484835984472544529509325440944131662631741403414037956695665533186650071476146389737020554215956181827422540843366433981607643940546405002217220286072880967331118344806315756304650248634546597784597963886656422706197757265316981889118026978865295597135470735576032282694348773714479076093197 e[5]=65537 e[6]=65537 e[7]=3 e[8]=5 e[9]=65537 e[10]=65537 e[11]=3 e[12]=5 e[13]=65537 e[14]=65537 e[15]=3 e[16]=5 e[17]=65537 e[18]=65537 e[19]=65537 e[20]=5 n[0]=90058705186558569935261948496132914380077312570281980020033760044382510933070450931241348678652103772768114420567119848142360867111065753301402088676701668212035175754850951897103338079978959810673297215370534716084813732883918187890434411552463739669878295417744080700424913250020348487161014643951785502867 n[1]=92921790800705826977497755832938592891062287903332844896046168726101016067456726822505517352409138948392871113192427210529297191908638888388136391240683157994654207338463678065440899870434887094216772312358731142317774259942199808535233769089985063860828267808621928898445383706310204223006136919334252875849 n[2]=90252653600964453524559669296618135272911289775949194922543520872164147768650421038176330053599968601135821750672685664360786595430028684419411893316074286312793730822963564220564616708573764764386830123818197183233443472506106828919670406785228124876225200632055727680225997407097843708009916059133498338129 n[3]=92270627783020341903769877272635163757611737252302329401876135487358785338853904185572496782685853218459404423868889360808646192858060332110830962463986164014331540336037718684606223893506327126112739408023014900003600028654929488487584130630596342720833061628867179840913592694993869009133576053124769728363 n[4]=90058705186558569935261948496132914380077312570281980020033760044382510933070450931241348678652103772768114420567119848142360867111065753301402088676701668212035175754850951897103338079978959810673297215370534716084813732883918187890434411552463739669878295417744080700424913250020348487161014643951785502867 n[5]=99193711547257063160816850544214924340574358752670644615293764532335872088470223740970673347993652626497557387222167784182876395436088845281840169701654629849214222297784511349059698963212947299142320497759258889425182705042123217476724761095690092179821753840224757786599021225709340258545979566824267620959 n[6]=146839643970016464813197409569004275595828791825722617066607993001682901023784267554815946189374651530288894322286859792246413142980277245909181062525398546369553995023529451396820549308690493928593324007689135648753323161394735120908960458860801743476353228970081369439513197105039143930008573928693059198131 n[7]=155266493936043103849855199987896813716831986416707080645036022909153373110367007140301635144950634879983289720164117794783088845393686109145443728632527874768524615377182297125716276153800765906014206797548230661764274997562670900115383324605843933035314110752560290540848152237316752573471110899212429555149 n[8]=102900163930497791064402577447949741195464555746599233552338455905339363524435647082637326033518083289523250670463907211548409422234391456982344516192210687545692054217151133151915216123275005464229534891629568864361154658107093228352829098251468904800809585061088484485542019575848774643260318502441084765867 n[9]=97767951046154372321400443371234495476461828137251939025051233003462769415459435471728054384852461870179980010660162922547425212869925648424741526671585598167502856111641944825179295197098826911226483155821197251989297102189187139234080795582529077092266799813985026581245196104843272305656744384140745492897 n[10]=93836514358344173762895084384953633159699750987954044414830106276642828025218933012478990865656107605541657809389659063108620208004740646099662700112782252200834393363574089818787717951026690934986964275526538236750596344542450864284576226592039259070002692883820960186403938410354082341916474419847211138467 n[11]=112306066601652819062206435724795595603085908011001671184332227488970057128128821831260649058569739569103298091727188365019228385820143813415009397359257831092635374404034997011441653286642458431865026213129412677064308342580757248577955071384972714557250468686599901682728173096745710849318629959223270431039 n[12]=90267480939368160749458049207367083180407266027531212674879245323647502822038591438536367206422215464489854541063867946215243190345476874546091188408120551902573113507876754578290674792643018845798263156849027209440979746485414654160320058352559498237296080490768064578067282805498131582552189186085941328701 n[13]=94390533992358895550704225180484604016029781604622607833044135524814562613596803297695605669157378162035217814540004231075201420796787547733762265959320018107419058832819010681344133011777479722382525797938558181629835768471461434560813554411133962651212455645589624432040989600687436833459731886703583047283 n[14]=120008876536855131221255979370745233738591934188224528487535120483456214085493237482915446419599357910343450285858995374277365393767669569942204888383426461862651659865189178784473131914234181752055950431093341514138390898892413182538823693941124637301582389014479754627419560568004831093116617428970538503551 n[15]=147733349387696521015664992396355145811249793103958464053225389476050097503928022819269482555955365534137156079172704297584033078453033637103720972881068435459202133846880715879894340131656691631756162323422868846616160423755883726450486845175227682329583615739797782025647376042249605775433971714513081755709 n[16]=90673177193017332602781813187879442725562909473411994052511479411887936365983777106776080722300002656952655125041151156684340743907349108729774157616323863062525593382279143395837261053976652138764279456528493914961780300269591722101449703932139132398288208673556967030162666354552157189525415838326249712949 n[17]=111178307033150739104608647474199786251516913698936331430121060587893564405482896814045419370401816305592149685291034839621072343496556225594365571727260237484885924615887468053644519779081871778996851601207571981072261232384577126377714005550318990486619636734701266032569413421915520143377137845245405768733 n[18]=93394639108667212482180458616036741615058981058942739509025631675767304945732437421192075466824789572910657586684470553691049259504106442090140927782673066834126848556317079995332229262871079799089771973100731889841015960713908117908583988637159206246729697336281050046919985463146705713899703248595045701819 n[19]=94154993593274109828418786834159728190797445711539243887409583756844882924221269576486611543668906670821879426307992404721925623741478677756083992902711765865503466687919799394258306574702184666207180530598057989884729154273423032471322027993848437082723045300784582836897839491321003685598931080456249945287 n[20]=90916739755838083837461026375700330885001446224187511395518230504776419813625940046511904838818660297497622072999229706061698225191645268591198600955240116302461331913178712722096591257619538927050886521512453691902946234986556913039431677697816965623861908091178749411071673467596883926097177996147858865293 c[0]=48641173720475702278690317652676924796340996697567087705119344461991930773386153198223372579328462635803653561516674380209276666328375805315553713680858906705068657158073776194628700821011001144559278784795978097710145192236347629751116534400207288736776545247409895672030976932673010818369814246455196991083 c[1]=1626661141529320283833484152716550848856697186049377493478368799832043379420727509223318694347625977694500761460048670101820769656612419734057871562023463159698522348510157125720014700549254630959391701883372400982386084212421115166791728704867253734354874934210987301137512341070190760227227749365878233484 c[2]=39632263504870478574861695051251850807454294787974709214866410237055871793939895562441267574482198916367858789237648434983815369123479208726344716594227785308836601932181727610859898951190206345056426253251079929822424252271957269630987623886812686545521745791771387808772030614435314730783528512800343192265 c[3]=83421434286602546493364204139182949897795123160498680670964040331447569764445309937195566103281638928183742488663157138572020817924561990979723444797045375101801354862472761507421896454904818874439231990567738173059815647539737800523632262742398190575822391771655932895657208471832891505814792263361394479317 c[4]=19560634556305755550927540610989537766715902244072312818350844104485773927537226443429404190213856361759564153804627450805880512600339869169513348929194643809859468549718922965997647689203029517135396008631050292544022651948009392475583045438153697076529266662217519588521116539517972522591294232192817502376 c[5]=26054677793581772924866273737009673285775062802734786532404396138990264566536537921648515854012553861999940229349708989519156563830916553754762208466745321226835312974971739761769324569315525872096987367001543758380071859429619580182411498650200401467760546057912183435480924905200466941116258838789328064564 c[6]=47190775807472506173587993082023759909601357229808667044044468676457696140445235738005020994278091230440755033222450219378047807646817722376918364211727971804312327204294555178996480944188624972632371674822397258127227029990196956900925820980263353418653201918881814896866168764140848945600419602253279143149 c[7]=124929943232081828105808318993257526364596580021564021377503915670544445679836588765369503919311404328043203272693851622132258819278328852726005776082575583793735570095307898828254568015886630010269615546857335790791577865565021730890364239443651479580968112031521485174068731577348690810906553798608040451024 c[8]=25585088950095290712328215701309273521406235982885781641137768116285362079062975527364909549362511146004390419156826709543326814581466248280564194951706937822088902607754944405407698735824315900942915322054614437632116732271787823814807624841386886185122143173564380877370643120953803688563589496390425159539 c[9]=14375950543873882011796759348848479283522955796749853113492047625299699702886303193822347995567175524401038661237990847185236138967814088030767785916645492142741397786256445305366822277551514353423864240674522264407918605662008550545442780563568811883349771003546081844527788515420708612431091464410712019656 c[10]=78852785408127338210375705302361611580033298047358566712385067002412358292419274287993295604646693755514055710305938805847184012173449160624823261013152092151242661538772012880714981492275731658527465442787266554947828301571586721387286510359738598116104180351027973922256460236377354127082438812404967605644 c[11]=108387832390337770947361518376552702503741092284778824448943971792044922720461955035726863109418657218498659460663504872870862538725835055240750735576735249122665348803252691221869146679004017916359067454693701495389784159620341860394035373599823801288442604273046729873467936004227013186659110262247417571857 c[12]=44374979291120575503988741531987454898919254880086464254904878064332010355432423956182135846738023874326776872139229379943321321362822522900479438294291206287205647145759972233097276253408812699557305314344220807356024994977399840843758750494467535572805794732065369887057841293267499209427585419962565568495 c[13]=41663689952657185984513733558388033289292857758748468070934326941659317694408873831451567385012905508903797893149006067280788298408959017459890579859784072677410890657854942639040056924596925599973762214900728648657052474974405878868755028761443878403349272421153452240103741921751653022646614028009138548572 c[14]=35133765260146855599194761500993159592311136378033858818728078464540389548474611501950689942825550399101504201020687961256642455745888410410524955937773951578993882275525944145131794970001708655718844507774877602125183877782393564092461821246419013099835940432551540513624090850765797735157630551978900512155 c[15]=52253817590056116368273294519761274350847193477090280916373828903718796358618956145225746496960677477661151583828604021049936963779103440560630451125137344639503705880024677345063113240530798352727432768980751992926293801206779839157443722614687126711272753610923903360818026083573711899014859313677159790039 c[16]=24086371701602948122317790211004032014326487279907486724991846810668564197542368948703436295770758262739732290677177527297040556666434577730354732397784651220918412407485171180732327730242552955646750279842251200227937257322414662213662054605527282812231172173474061845763736546747711105935349033514358348526 c[17]=1395222187334055833498435136007269572138525113145744882969531037442244086277594803865217301719947066153176244638660864035949705664670633245110847416168796640199238733478540080417312141011028469385167826450855601412915611725028631975605932279023918771764204031806414734015476034106891049334159757621016327648 c[18]=49047978458885807127192385282227726754593888749388775377492411121925201201621099927332087316607446894372751446254341808051569111053293066232980434901592875347200122022210780536817524813076908750647137301610117592355818408280291766068780616226847056325075159440352473034526412778650516438709293396458312728764 c[19]=52958695992371180409414011678115981405835026800648278393085136639708219930134280877954018305615378579281651249142230848262822421713895227069561145945972448893229231020632492517869034217943260664130647322694583182800800838539691542175229797652856708373533581250607375664993806654537737027000328299623032632769 c[20]=23204039098754030513954332212496652705175644349879686639449689791620605370809827884267260830136516742466455588549253481016504796674014871020503543639681251834114159250986728840380777774144853925216884802529230212783759821262799845229436535491711201551797166082529740271577684082458494926929260818927584104158 结果分析 遍历所有的模数N，判断是否存在模数相同的加密片段，如果猜测可以用共模攻击\n遍历寻找任意两个模数N的公因子，如果得到不为1的公因子则可以因数碰撞\n#遍历所有模数,找到模数相同的加密密文 for i in range(0,21): for j in range(i+1,21): if n[i]==n[j]: print(\u0026#39;n[\u0026#39;+str(i)+\u0026#39;]==\u0026#39;+\u0026#39;n[\u0026#39;+str(j)+\u0026#39;]\u0026#39;) #遍历寻找任意两个模数N的公因子，如果得到不为1的公因子则可以成功分解这两个模数 for i in range(0,21): for j in range(i+1,21): if n[i]==n[j]: continue else: rem=math.gcd(n[i],n[j]) if rem!=1: print(\u0026#39;gcd(n[\u0026#39;+str(i)+\u0026#39;],n[\u0026#39;+str(j)+\u0026#39;]\u0026gt;1\u0026#39;) 结果 #n[0]==n[4] #gcd(n[1],n[18])\u0026gt;1 遍历所有加密指数e，寻找低加密指数及对应的加密对，可以用低指数广播攻击\ne[0]=46786465362686334917265996843779843233606992585424976481745055335468678697948774988450305612127967926533923268260412557000125153569622340353246096040604284883505587337829322949633637609180797447754513992039018904786537115087888005528547900640339270052628915440787357271345416818313808448127098885767015748889 e[1]=e[2]=e[5]=e[6]=e[9]=e[10]=e[13]=e[14]=e[17]=e[18]=e[19]=65537 e[2]=65537 e[3]=e[8]=e[12]=e[16]=e[20]=5 e[4]=152206992575706893484835984472544529509325440944131662631741403414037956695665533186650071476146389737020554215956181827422540843366433981607643940546405002217220286072880967331118344806315756304650248634546597784597963886656422706197757265316981889118026978865295597135470735576032282694348773714479076093197 e[7]=e[11]=e[15]=3 对上述的公钥e进行分析,主要有以下几种，其中e比较小的有3和5，其中\nFrame7，Frame11，Frame15采用低加密指数e=3进行加密\nFrame3，Frame8，Frame12，Frame16和Frame20均采用低加密指数e=5进行加密\n采用费马分解尝试p,q差距比较小的帧和Pollard p-1分解进行尝试p,q差距比较大的帧\nFrame10可以用费马分解法破解\nFrame2，6，19可以用p-1分解法破解\nBaidu or Google Hack\n实例破解 公共模数攻击 n[0]==n[4],还因为可能存在重复发包\n设两个用户的公钥分别为 $e_1$ 和 $e_2$ ，且两者互质。明文消息为 $m$ ，密文分别为: $$ \\begin{aligned} \u0026amp;c_1=m^{e_1} \\bmod n \\ \u0026amp;c_2=m^{e_2} \\bmod n \\end{aligned} $$ 当攻击者截获 $c_1$ 和 $c_2$ 后，就可以恢复出明文。用扩展欧几里得算法求出 $r e_1+s e_2=1 \\bmod n$ 的两个整数 $r$ 和 $s$ ，由此可得: $$ \\begin{aligned} c_1^r c_2^s \u0026amp; \\equiv m^{r e_1} m^{s e_2} \\bmod n \\ \u0026amp; \\equiv m^{\\left(r e_1+s e_2\\right)} \\bmod n \\ \u0026amp; \\equiv m \\bmod n \\end{aligned} $$\n#公共模数攻击 #扩展欧几里得算法 def exgcd(a,b): if b==0: return 1,0,a else: x,y,r=exgcd(b,a%b) x,y=y,(x-(a//b)*y) return x,y,r def same_mod_attack(n,e1,e2,c1,c2): x,y,r=exgcd(e1,e2) #求模逆元 if x\u0026lt;0: x=-x; c1=gmpy2.invert(c1,n) elif y\u0026lt;0: y=-y; c2=gmpy2.invert(c2,n) #求解明文 m=pow(c1,x,n)*pow(c2,y,n)%n #将明文转换为hex m=hex(m)[2:]#去掉0x #将hex转换为str m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str return m if __name__ == \u0026#39;__main__\u0026#39;: #公共模数攻击 for i in range(0,21): for j in range(i+1,21): if n[i]==n[j]: m2=same_mod_attack(n[i],e[i],e[j],c[i],c[j]) sloved[\u0026#39;Frame\u0026#39;+str(i)]=m2 sloved[\u0026#39;Frame\u0026#39;+str(j)]=m2 print(sloved) {\u0026lsquo;Frame0\u0026rsquo;: b\u0026rsquo;My secre\u0026rsquo;, \u0026lsquo;Frame4\u0026rsquo;: b\u0026rsquo;My secre\u0026rsquo;}\n公因数碰撞攻击 Frame1、Frame18采用该种攻击方法\n因数碰撞法指的是, 如果参数选取不当, $p$ 或者 $q$ 在多个RSA加密中出现多次，那么生成不同的 $\\mathrm{n}$ 可能会有相同的因子，我们假设 $\\mathrm{p}$相同,$\\mathrm{q}$不同，那么在 $$ \\left{\\begin{array}{l} n_1=p * q_1 \\ n_2=p * q_2 \\end{array}\\right. $$ 很容易知道 $$ \\operatorname{gcd}\\left(n_1, n_2\\right)=p $$ 这样很快就能将他们各自的私钥求解出来了。 代码过于简单, 直接gcd两个因数就行, 结果不为1就说明有相同因数。\n#公因数碰撞攻击 def same_factor_attack(): p_of_prime=gmpy2.gcd(n[1],n[18]) q1=n[1]//p_of_prime q18=n[18]//p_of_prime phi1=(p_of_prime-1)*(q1-1)#计算欧拉函数 phi18=(p_of_prime-1)*(q18-1)#计算欧拉函数 d1=gmpy2.invert(e[1],phi1)#计算私钥 d18=gmpy2.invert(e[18],phi18)#计算私钥 m1=pow(c[1],d1,n[1])#解密 m18=pow(c[18],d18,n[18])#解密 m1=hex(m1)[2:]#去掉0x m18=hex(m18)[2:]#去掉0x m1=binascii.unhexlify(m1)[-8:]#hex-\u0026gt;str m18=binascii.unhexlify(m18)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame1\u0026#39;]=m1 sloved[\u0026#39;Frame18\u0026#39;]=m18 \u0026lsquo;Frame1\u0026rsquo;: b\u0026rsquo;. Imagin\u0026rsquo;, \u0026lsquo;Frame18\u0026rsquo;: b\u0026rsquo;m A to B\u0026rsquo;\n低指数广播攻击 Frame3、Frame8、Frame12、Frame16、Frame20采用该种攻击方法\n低加密指数广播攻击适合于$\\mathrm{n}$很大,$e$很小的情况, 其适用的情况是如$\\mathrm{n}$下的，当一条消息$m$发送给不同的接收者时，每个接收者的 $n$ 都不同，但是加密公钥都是相同的，我们假设公钥为3那么就有 $$ \\left{\\begin{array}{l} C_1=m^3 \\bmod n_1 \\ C_2=m^3 \\bmod n_2 \\ C_3=m^3 \\bmod n_3 \\end{array}\\right. $$ 由中国剩余定理知道,我们是可以将 $m^3$ 算出来的，那么对其开立方就将明文给求出来了。\n#中国剩余定理 def chinese_remainder_theorem(backup): #计算N的乘积 N=1 for a,n in backup: N*=n #计算Ni Ni=[] for a,n in backup: Ni.append(N//n) #计算Ni的模逆元 Ni_inverse=[] for i in range(0,len(Ni)): Ni_inverse.append(gmpy2.invert(Ni[i],backup[i][1])) #计算x x=0 for i in range(0,len(Ni)): x+=backup[i][0]*Ni[i]*Ni_inverse[i] x=x%N return x,N #低指数3 def low_exponent_attack3(): frame_range=[7,11,15] backup=[] for i in frame_range: backup.append([c[i],n[i]]) x,N=chinese_remainder_theorem(backup) #开三次方根 m=gmpy2.iroot(x,3)[0] m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame7\u0026#39;]=m sloved[\u0026#39;Frame11\u0026#39;]=m sloved[\u0026#39;Frame15\u0026#39;]=m #低指数5 def low_exponent_attack5(): frame_range=[3,8,12,16,20] backup=[] for i in frame_range: backup.append([c[i],n[i]]) x,N=chinese_remainder_theorem(backup) #开五次方根 m=gmpy2.iroot(x,5)[0] m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame3\u0026#39;]=m sloved[\u0026#39;Frame8\u0026#39;]=m sloved[\u0026#39;Frame12\u0026#39;]=m sloved[\u0026#39;Frame16\u0026#39;]=m sloved[\u0026#39;Frame20\u0026#39;]=m \u0026lsquo;Frame7\u0026rsquo;: b\u0026rsquo;\\xb8\\xbc\\xa2S)s\\xcd\\xd2\u0026rsquo;, \u0026lsquo;Frame11\u0026rsquo;: b\u0026rsquo;\\xb8\\xbc\\xa2S)s\\xcd\\xd2\u0026rsquo;, \u0026lsquo;Frame15\u0026rsquo;: b\u0026rsquo;\\xb8\\xbc\\xa2S)s\\xcd\\xd2\u0026rsquo;, \u0026lsquo;Frame3\u0026rsquo;: b\u0026rsquo;t is a f\u0026rsquo;, \u0026lsquo;Frame8\u0026rsquo;: b\u0026rsquo;t is a f\u0026rsquo;, \u0026lsquo;Frame12\u0026rsquo;: b\u0026rsquo;t is a f\u0026rsquo;, \u0026lsquo;Frame16\u0026rsquo;: b\u0026rsquo;t is a f\u0026rsquo;, \u0026lsquo;Frame20\u0026rsquo;: b\u0026rsquo;t is a f\u0026rsquo;\n可以看到Frame7，Frame11，Frame15采用低加密指数广播攻击出来是乱码，说明该种方法不正确\nFrame3、Frame8、Frame12、Frame16、Frame20可以采用该种攻击方法\nCoppersmith广播攻击 Coppersmith 是干了这么一件事: 今有一个 $e$ 阶的多项式 $f$, 那么可以:\n在模 $n$ 意义下，快速求出 $n^{1 / e}$ 以内的根\n给定 $\\beta$ ，快速求出模某个 $b$ 意义下较小的根，其中 $b \\geq n^\\beta$ ，是 $n$ 的因数。\nPollard p-1分解法 Frame2、Frame6、Frame19均采用该种攻击方法\nPollard p-1分解法是一种用于分解大质数的算法，它是Pollard rho算法的一种变体。它的基本思想是利用费马小定理来找到大质数的一个小因子。\n如果 $p$ 与 $q$ 都不超过 $10^{20}$ 次方, 若其中一个 $(p-1)$ 或 $(q-1)$ 的因子都很小的时候（适用于p-1或q-1能够被小素数整除的情况,在这里为了方便说明我们假设为 $(p-1))$ ,可以如下操作: 选取一个整数 $k$, 使其满足 $(p-1) \\mid k!$，由费马小定理知道, $a$ 与 $p$ 互素 的时候有 $$ a^{p-1}=1 \\bmod p $$ 所以 $a^{k !}=1 \\bmod p \\quad, \\quad$即 $\\mathrm{p} \\mid\\left(a^{k !}-1\\right)$ 。 那么对于 $\\mathrm{n}$ 与 $\\left(a^{k !}-1\\right)$ 必有公因数为 $\\mathrm{p}$, 这样就可以把 $\\mathrm{n}$ 分解出来了。 但是对于 $k$ 的选取还是有要求的，太小了 $(p-1) \\mid k !$不会成立，太大了花费时间会很多。\n首先选取一个合适的整数a和一个正整数B； 选择一个整数k，使得k满足2\u0026lt;=k\u0026lt;=B； 计算$a^k ~ mod ~ n$，然后将其与n计算最大公因数，记为d； 如果d是n的因子，则输出d；否则，将d作为下一次迭代的起点，重复执行第3步和第4步，直到找到一个因子或者达到最大迭代次数为止。 在实际使用中，可以选择多个不同的a值和不同的B值，然后分别运行p-1分解法，取所有得到的因子的最大公因数作为最终的结果。\n需要注意的是，p-1分解法的效率取决于选取的参数a和B的大小。如果a过小或B过大，算法可能无法找到因子；如果a过大或B过小，算法可能会陷入循环而无法得到结果。因此，在实际应用中需要进行合理的参数选择。\nGet $\\mathrm{n}$, an odd integer to be factored.\nLet $\\mathrm{a}=2$ and $\\mathrm{i}=2$.\nCompute $a=a^i \\bmod n$.\nCompute $\\mathrm{d}=\\operatorname{gcd}(\\mathrm{a}-1, \\mathrm{n})$.\nIf $1\u0026lt;\\mathrm{d}\u0026lt;\\mathrm{n}$, then output $\\mathrm{d}$ as a factor of $\\mathrm{n}$.\nIf $\\mathrm{d}=1$, then $\\mathrm{i}=\\mathrm{i}+1$, and go to step 3.\n#Pollard\u0026#39;s p-1算法 def pollard_p_1(n): b=2**20 a=2 for i in range(2,b+1): a=gmpy2.powmod(a,i,n) d=gmpy2.gcd(a-1,n) if d!=1 and d!=n: q=n//d n=q*d return d def pollard_data(n): frame_range=[2,6,19] for i in frame_range: temp_n=n[i] temp_c=c[i] temp_e=e[i] p=pollard_p_1(temp_n) q=temp_n//p phi=(p-1)*(q-1) d=gmpy2.invert(temp_e,phi) m=pow(temp_c,d,temp_n) m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame\u0026#39;+str(i)]=m \u0026lsquo;Frame2\u0026rsquo;: b\u0026rsquo; That is\u0026rsquo;, \u0026lsquo;Frame6\u0026rsquo;: b\u0026rsquo; \u0026ldquo;Logic \u0026lsquo;, \u0026lsquo;Frame19\u0026rsquo;: b\u0026rsquo;instein.\u0026rsquo;\n费马分解法 如果 $p$ 和 $q$ 相差不大的话我们可以通过费马分解把 $p$ 和 $q$ 求出来, 原理如 下 $$ \\mathrm{n}=\\mathrm{p} * \\mathrm{q}=\\frac{1}{4}(p+q)^2-\\frac{1}{4}(p-q)^2 $$ 由于 $\\mathrm{p}$ 与 $\\mathrm{q}$ 相差不大, 所以 $\\mathrm{p}-\\mathrm{q}$ 相对于 $\\mathrm{n}$ 和 $(p+q)^2$ 来说可以忽略不计, 所以有～ $$ 2 \\sqrt{\\mathrm{n}} \\approx \\mathrm{p}+\\mathrm{q} $$ 也就是说通过不断尝试就可以把 $\\mathrm{p}$ 和 $\\mathrm{q}$ 给计算出来了\np、q比较接近时，可以使用这种攻击方法\n# 费马分解 def fermat_factorization(n): a=gmpy2.iroot(n,2)[0]+1 max=200000 for i in range(0,max): b2=a*a-n b=gmpy2.iroot(b2,2)[0] if gmpy2.is_square(b2): p=a-b q=a+b return p,q a+=1 def fermat_data(): frame_range=[10] for i in frame_range: p,q=fermat_factorization(n[i]) phi=(p-1)*(q-1)#计算欧拉函数 d=gmpy2.invert(e[i],phi)#计算私钥 m=pow(c[i],d,n[i])#解密 m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame\u0026#39;+str(i)]=m 经检验,Frame10可以采用该种攻击方法\n\u0026lsquo;Frame10\u0026rsquo;: b\u0026rsquo;will get\u0026rsquo;\n总结 帧号 value solution Frame0 My secre 公共模数攻击 Frame1 . Imagin 公因数碰撞攻击 Frame2 That is Pollard rho-p-1分解法 Frame3 t is a f 低指数广播攻击 Frame4 My secre 公共模数攻击 Frame5 Frame6 \u0026ldquo;Logic Pollard rho-p-1分解法 Frame7 \\xb8\\xbc\\xa2S)s\\xcd\\xd2 Frame8 t is a f 低指数广播攻击 Frame9 Frame10 will get 费马分解法 Frame11 \\xb8\\xbc\\xa2S)s\\xcd\\xd2 Frame12 t is a f 低指数广播攻击 Frame13 Frame14 Frame15 \\xb8\\xbc\\xa2S)s\\xcd\\xd2 Frame16 t is a f 低指数广播攻击 Frame17 Frame18 m A to B 公因数碰撞攻击 Frame19 instein. Pollard rho-p-1分解法 Frame20 t is a f 低指数广播攻击 整理一下My secret is a f__instein. That is \u0026ldquo;Logic will get__m A to B. Imagin__\n根据搜索结果可以补全后面的saying的内容,根据语义也可以填充前面的内容\nMy secret is a famous saying of Albert Einstein. That is \u0026ldquo;Logic will get you from A to B. Imagination will take you everywhere.“\n​\t参考链接 [2016 全国高校密码数学挑战赛-赛题三] https://www.tr0y.wang/2017/10/31/RSA2016/\n[现代密码学大作业] https://blog.csdn.net/m0_63571390/article/details/122375466?spm=1001.2014.3001.5501\n[关于RSA的几种攻击手段] https://blog.csdn.net/pigeon_1/article/details/114371456\n[Twenty Years of Attacks on the RSA Cryptosystem] https://www.ams.org/notices/199902/boneh.pdf\n[On using Pollard’s p-1 Algorithm to Factor RPrime RSA Modulus] https://www.scitepress.org/Papers/2018/100836/100836.pdf\n完整代码 import binascii import gmpy2 import math n=[]#模数集合 e=[]#公钥指数集合 c=[]#密文集合 m={zip([\u0026#39;Frame\u0026#39;+str(i) for i in range(0,21)],\u0026#39;\u0026#39;)} # Path: code\\main.py sloved={}#已解密的密文集合 filename=[\u0026#39;data\\Frame\u0026#39;+str(i) for i in range(0,21)]#文件名集合 # print(filename) for i in range(0,21): f=open(filename[i],\u0026#39;r\u0026#39;) data=f.read() #str-\u0026gt;hex-\u0026gt;int n.append(int(data[:256],16)) e.append(int(data[256:512],16)) c.append(int(data[512:],16)) #输出e的值 # for i in range(0,21): # print(\u0026#39;e[\u0026#39;+str(i)+\u0026#39;]=\u0026#39;+str(e[i])) # #输出n的值 # for i in range(0,21): # print(\u0026#39;n[\u0026#39;+str(i)+\u0026#39;]=\u0026#39;+str(n[i])) # #输出c的 # for i in range(0,21): # print(\u0026#39;c[\u0026#39;+str(i)+\u0026#39;]=\u0026#39;+str(c[i])) #遍历所有模数,找到模数相同的加密密文 for i in range(0,21): for j in range(i+1,21): if n[i]==n[j]: print(\u0026#39;n[\u0026#39;+str(i)+\u0026#39;]==\u0026#39;+\u0026#39;n[\u0026#39;+str(j)+\u0026#39;]\u0026#39;) #遍历寻找任意两个模数N的公因子，如果得到不为1的公因子则可以成功分解这两个模数 for i in range(0,21): for j in range(i+1,21): if n[i]==n[j]: continue else: rem=math.gcd(n[i],n[j]) if rem!=1: print(\u0026#39;gcd(n[\u0026#39;+str(i)+\u0026#39;],n[\u0026#39;+str(j)+\u0026#39;])=\u0026#39;+str(rem)) #公共模数攻击 #扩展欧几里得算法 def exgcd(a,b): if b==0: return 1,0,a else: x,y,r=exgcd(b,a%b) x,y=y,(x-(a//b)*y) return x,y,r def same_mod_attack(n,e1,e2,c1,c2): x,y,r=exgcd(e1,e2) #求模逆元 if x\u0026lt;0: x=-x; c1=gmpy2.invert(c1,n) elif y\u0026lt;0: y=-y; c2=gmpy2.invert(c2,n) #求解明文 m=pow(c1,x,n)*pow(c2,y,n)%n #将明文转换为hex m=hex(m)[2:]#去掉0x #将hex转换为str m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str return m #公因数碰撞攻击 def same_factor_attack(): p_of_prime=gmpy2.gcd(n[1],n[18]) q1=n[1]//p_of_prime q18=n[18]//p_of_prime phi1=(p_of_prime-1)*(q1-1)#计算欧拉函数 phi18=(p_of_prime-1)*(q18-1)#计算欧拉函数 d1=gmpy2.invert(e[1],phi1)#计算私钥 d18=gmpy2.invert(e[18],phi18)#计算私钥 m1=pow(c[1],d1,n[1])#解密 m18=pow(c[18],d18,n[18])#解密 m1=hex(m1)[2:]#去掉0x m18=hex(m18)[2:]#去掉0x m1=binascii.unhexlify(m1)[-8:]#hex-\u0026gt;str m18=binascii.unhexlify(m18)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame1\u0026#39;]=m1 sloved[\u0026#39;Frame18\u0026#39;]=m18 #中国剩余定理 def chinese_remainder_theorem(backup): #计算N的乘积 N=1 for a,n in backup: N*=n #计算Ni Ni=[] for a,n in backup: Ni.append(N//n) #计算Ni的模逆元 Ni_inverse=[] for i in range(0,len(Ni)): Ni_inverse.append(gmpy2.invert(Ni[i],backup[i][1])) #计算x x=0 for i in range(0,len(Ni)): x+=backup[i][0]*Ni[i]*Ni_inverse[i] x=x%N return x,N #低指数3 def low_exponent_attack3(): frame_range=[7,11,15] backup=[] for i in frame_range: backup.append([c[i],n[i]]) x,N=chinese_remainder_theorem(backup) #开三次方根 m=gmpy2.iroot(x,3)[0] m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame7\u0026#39;]=m sloved[\u0026#39;Frame11\u0026#39;]=m sloved[\u0026#39;Frame15\u0026#39;]=m #低指数5 def low_exponent_attack5(): frame_range=[3,8,12,16,20] backup=[] for i in frame_range: backup.append([c[i],n[i]]) x,N=chinese_remainder_theorem(backup) #开五次方根 m=gmpy2.iroot(x,5)[0] m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame3\u0026#39;]=m sloved[\u0026#39;Frame8\u0026#39;]=m sloved[\u0026#39;Frame12\u0026#39;]=m sloved[\u0026#39;Frame16\u0026#39;]=m sloved[\u0026#39;Frame20\u0026#39;]=m # 费马分解 def fermat_factorization(n): a=gmpy2.iroot(n,2)[0]+1 max=200000 for i in range(0,max): b2=a*a-n b=gmpy2.iroot(b2,2)[0] if gmpy2.is_square(b2): p=a-b q=a+b return p,q a+=1 def fermat_data(): frame_range=[10] for i in frame_range: p,q=fermat_factorization(n[i]) phi=(p-1)*(q-1)#计算欧拉函数 d=gmpy2.invert(e[i],phi)#计算私钥 m=pow(c[i],d,n[i])#解密 m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame\u0026#39;+str(i)]=m #Pollard\u0026#39;s p-1算法 def pollard_p_1(n): b=2**20 a=2 # while True: # a=gmpy2.powmod(a,b,n) # d=gmpy2.gcd(a-1,n) # if d!=1 and d!=n: # return d # a+=1 for i in range(2,b+1): a=gmpy2.powmod(a,i,n) d=gmpy2.gcd(a-1,n) if d!=1 and d!=n: q=n//d n=q*d return d def pollard_data(n): frame_range=[2,6,19] for i in frame_range: temp_n=n[i] temp_c=c[i] temp_e=e[i] p=pollard_p_1(temp_n) q=temp_n//p phi=(p-1)*(q-1) d=gmpy2.invert(temp_e,phi) m=pow(temp_c,d,temp_n) m=hex(m)[2:]#去掉0x m=binascii.unhexlify(m)[-8:]#hex-\u0026gt;str sloved[\u0026#39;Frame\u0026#39;+str(i)]=m if __name__ == \u0026#39;__main__\u0026#39;: #公共模数攻击 for i in range(0,21): for j in range(i+1,21): if n[i]==n[j]: m2=same_mod_attack(n[i],e[i],e[j],c[i],c[j]) sloved[\u0026#39;Frame\u0026#39;+str(i)]=m2 sloved[\u0026#39;Frame\u0026#39;+str(j)]=m2 #公因数碰撞攻击 same_factor_attack() print(sloved) #低指数攻击 low_exponent_attack3() low_exponent_attack5() print(sloved) #费马分解 fermat_data() print(sloved) #Pollard\u0026#39;s p-1算法 pollard_data(n) print(sloved) #输出将地点按照帧数排序 for i in range(1,21): Frame_name=\u0026#39;Frame\u0026#39;+str(i) if Frame_name in sloved: print(Frame_name+\u0026#39;:\u0026#39;) print(sloved[Frame_name]) else: print(Frame_name+\u0026#39;:Not sloved\u0026#39;) ","permalink":"https://niceasiv.cn/posts/rsaattack/","summary":"题目摘要 赛题名称： RSA 加密体制破译 赛题描述 RSA密码算法是使用最为广泛的公钥密码体制。该体制简单且易于实现，只需要选择5个参数即可（两个素数$𝑝$和$𝑞$、模数$𝑁=𝑝𝑞$、加密指数$𝑒$和解密指数$𝑑$。设𝑚为待加密消息RSA体制破译相当于已知$𝑚^𝑒$ $mod$ $𝑁$能否还原𝑚的数论问题。目前模数规模为1024比特的RSA算法一般情况下是安全的，但是如果参数选取不当，同样存在被破译的可能。有人制作了一个RSA加解密软件采用的RSA体制的参数特点描述见密码背景部分）。\n已知该软件发送某个明文的所有参数和加密过程的全部数据（加密案例文件详见附件3-1。Alice使用该软件发送了一个通关密语，且所有加密数据已经被截获，请问能否仅从加密数据恢复该通关密语及RSA体制参数？如能请给出原文和参数，如不能请给出已恢复部分并说明剩余部分不能恢复的理由？\n加密过程 原始明文 This is a test of my RSA system. Frame0\nA5F51EB02EA9C0CC9B96926A08A761FE3E7CDB6E5B348DBEAEC761DBCFCDB15A6C76F8EE08196008AE60E396D7E228C6DAFC3CC1127F16EC87576B89C151F20F99098621FD46872BC92CDA8C915B758E5C0CACB994F55B8705B938126E08589E2502A7B9019C9A62E82392E8449E00CFC7DA17B8CDE92F9516CE9A2009F42DD900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100019726C82FED1E6CD58DE825528AE5634653C9921CAE02AFF7325F20D6E7085B7C8E3DC78D7518A78A8BC7D07E2E837083324579510851827794AE3D1FB9BAB360B1413A8F171A83804CEA73DFBC1248139BB27EB7D5BAD724AD8B08F51888B90562AF950725ACDD698F817AE62746CEA09479A191A6552B0116830355C68D0F61 Frame1\nA5F51EB02EA9C0CC9B96926A08A761FE3E7CDB6E5B348DBEAEC761DBCFCDB15A6C76F8EE08196008AE60E396D7E228C6DAFC3CC1127F16EC87576B89C151F20F99098621FD46872BC92CDA8C915B758E5C0CACB994F55B8705B938126E08589E2502A7B9019C9A62E82392E8449E00CFC7DA17B8CDE92F9516CE9A2009F42DD90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001789018FDB800AD59A54D27A77F280515BB3BFAB1CD75CB0A255A116D4A44849459FD887FF091F87C0B3E6305F019700E4E4CB3646D1DF276DFB87C4F64245F77377508EC6A796236F8ABB125023D3F4B898F55E3342D0A852193AF890990EA82F12FC85917BF132F2A58C449648D6E934B24E80307AB092DB18110D77BBA0F8E Frame2\nBA645145D9DE58B0FFA6FC4624A2815092D2A2DC405E7A2515F985727D3C52F479A4D04694568CA9B08391BE79BD122808CF6034AB7251088687BFF5916A4F4723FE1372DCF9B069CAB269A9F8F47CB50078D3279B9452C9B3B65A07B49C793783EDB8EB8D8F1A220D9EFED33147483103A2551A96932738255493F13B5119530000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001534810A0D1B2F6FB257DC3BBDA30AA76157B89038E52D05EE1E5DB06C2D79FAE84892950EF5FD8ADC4F241C3741AD7C97002902C8CA4D96574F28EDCEF3BEF15303335FA8D250102B4EE77E3B405E30F6B81E92403A8881285B65F29668E05B9CD6AC44FC1CD193CF4A5811A2649BE0EDEFBA91FA7143266286C5EC6EE8077D6 Frame3\nBA645145D9DE58B0FFA6FC4624A2815092D2A2DC405E7A2515F985727D3C52F479A4D04694568CA9B08391BE79BD122808CF6034AB7251088687BFF5916A4F4723FE1372DCF9B069CAB269A9F8F47CB50078D3279B9452C9B3B65A07B49C793783EDB8EB8D8F1A220D9EFED33147483103A2551A96932738255493F13B51195300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100018805A937DABF25FE760F9F398C7D9D5955EF7468FEC89119F8DD69874FB009AB2C424BD6A8E85401C4CD130B48D0490586DFBD81C8154EDCEFC3AFC4F80338432197EB059AB54CF109B231416FB65E2F9BE4F01D455E25486D8E155A5874E8A910E8C65F73ACD953D316B35A148D5AC5834D86F66AD415EBA38AD3908B32780A 2.过程及参数\nRSA 密码算法描述如下，包含体制参数选取和加解密过程。\n1）RSA 体制参数选取\n​ Step1.每个使用者，任意选择两个大素数$𝑝$和$𝑞$，并求出其乘积$𝑁=𝑝𝑞$。\n​ Step2.令$𝜑(𝑁)=(𝑝−1)(𝑞−1)$选择整数$𝑒$，使得$GCD(𝑒,𝜑(𝑁))=1$，并求出$𝑒$模 $𝜑(𝑁)$的逆元$𝑑$，即$𝑒𝑑≡1 mod (𝜑(𝑁))$\n​ Step3.将数对$(𝑒,𝑁)$公布为公钥，$𝑑$保存为私钥。\n2）加解密过程\n​ Bob欲传递明文𝑚给 Alice，则Bob首先由公开途径找出 Alice 的公钥 $(𝑒,𝑁)$，Bob 计算加密的信息$𝑐$为:$𝑐 ≡ 𝑚^𝑒$ $mod$ $𝑁$。\n​ Bob 将密文$𝑐$传送给 Alice。 随后 Alice 利用自己的私钥$𝑑$解密： ​ $𝑐^e ≡ (𝑚^𝑒)^𝑑 ≡ 𝑚^{𝑒𝑑}≡ 𝑚\\space mod\\space 𝑁$\nAlice 使用的 RSA 密码体制有以下事项需要说明：\n​\t1）模数𝑁=𝑝𝑞规模为1024比特，其中𝑝，𝑞为素数；\n​\t2）素数𝑝由某一随机数发生器生成；\n​\t3）素数𝑞可以随机选择，也可以由2）中的随机数发生器产生；\n​\t4）可以对文本加密，每次加密最多8个明文字符；\n​\t5）明文超过8个字符时，对明文分片，每个分片不超过8个字符；\n​\t6）分片==明文填充为512比特消息后再进行加密，填充规则为高位添加64比特标志位，随后加上32比特通信序号==，再添加若干个0，最后64比特为明文分片字符对应的ASCII码（**注：填充方式参见加密案例，但注意每次通信的标志位可能变化）\n​\t7）分片加密后发送一个加密帧数据，帧数据文件名称为FrameXX，其中XX表示接收序号，该序号不一定等于通信序号；\n​\t8）帧数据的数据格式如下，其中数据都是16进制表示，结构如下==1024bit模数N | 1024bit加密指数e | 1024bit密文== $m^e\\space mod \\space N$。\n​\t9）由于Alice初次使用该软件，可能会重复发送某一明文分片。\n符号说明： n 模数、p 素数、q素数、e加密指数、d 解密指数、m 明文分片、c 密文分片、“0X”十六进制数据表示\n明文： \u0026ldquo;This is a test of my RSA system.\u0026ldquo;将其分割为4个8字符长度消息(注意：空格也是一个字符)\nThis is 该8字符对应的ASCII为\t54\t68\t69\t73\t20\t69\t73\t20\t将其视为64比特整数为==\u0026gt;\t0X5468697320697320 a test o\t该8字符对应的ASCII为\t61\t20\t74\t65\t73\t74\t20\t6F\t将其视为64比特整数为==\u0026gt;\t0X612074657374206F f my RSA\t该8字符对应的ASCII为\t66\t20\t6D\t79\t20\t52\t53\t41\t将其视为64比特整数为==\u0026gt;\t0X66206D7920525341 system.","title":"RSA 加密体制破译"},{"content":"Content 更好的效果PDF:pdf文章列表 | Asiv\u0026rsquo;s Blog (niceasiv.cn)\nFactoring challenge #1: Your goal in this project is to break RSA when the public modulus $N$ is generated incorrectly. This should serve as yet another reminder not to implement crypto primitives yourself.\nNormally, the primes that comprise an RSA modulus are generated independently of one another. But suppose a developer decides to generate the first prime $p$ by choosing a random number $R$ and scanning for a prime close by. The second prime $q$ is generated by scanning for some other random prime also close to $R$. We show that the resulting RSA modulus $N=p q$ can be easily factored.\n在公开的N没有被正确的生成时破解RSA。通常在RSA中构成模数N的素数q和p,应该独立生成。如果开发者使用一个随机数R,并选择R附近的两个素数作为q和p，那么这种情况情况下生成的RSA模数N就很容易被破解。\nSuppose you are given a composite(合数) $N$ and are told that $N$ is a product of two relatively close primes $p$ and $q$, namely $p$ and $q$ satisfy $$ |p-q|\u0026lt;2 N^{1 / 4} $$ Your goal is to factor $N$. Let $A$ be the arithmetic(算数) average of the two primes, that is $A=\\frac{p+q}{2}$. Since $p$ and $q$ are odd(奇数), we know that $p+q$ is even and therefore $A$ is an integer(整数).\n可以得到 $A=\\frac{p+q}{2}\u0026lt;N^{\\frac{1}{4}}$\nTo factor $N$ you first observe that under condition $\\left.{ }^\\right)$ the quantity $\\sqrt{N}$ is very close to $A$. In particular, we show below that: $$ {A-\\sqrt{N}\u0026lt;1} $$ But since $A$ is an integer, rounding $\\sqrt{N}$ up to the closest integer reveals the value of $A$. In code, $A=$ ceil $(\\operatorname{sqrt}(N))$ where \u0026ldquo;ceil\u0026rdquo; is the ceiling function. Visually, the numbers $p, q, \\sqrt{N}$ and $A$ are ordered as follows:\nSince $A$ is the exact mid-point between $p$ and $q$ there is an integer $x$ such that $p=A-x$ and $q=A+x$. But then $N=p q=(A-x)(A+x)=A^2-x^2$ and therefore $x=\\sqrt{A^2-N}$.\nNow, given $x$ and $A$ you can find the factors $p$ and $q$ of $N$ since $p=A-x$ and $q=A+x$. You have now factored $N$ !\n因为$A$是$p$,$q$的中点\n$\\therefore$ $p=A-x$ $q=A+x$$\\implies N=p q=(A-x)(A+x)=A^2-x^2$\n$\\therefore x=\\sqrt{A^2-N}$\n所以得到$x$的值可以得到$p,q$的取值\nFurther reading: the method described above is a greatly simplified version of a much more general result on factoring when the high order bits of the prime factor are known.\nIn the following challenges, you will factor the given moduli using the method outlined above. To solve this assignment it is best to use an environment that supports multi-precision arithmetic and square roots. In Python you could use the gmpy2 module. In C you can use GMP.\nThe following modulus $N$ is a products of two primes $p$ and $q$ where $|p-q|\u0026lt;2 N^{1 / 4}*$. Find the smaller of the two factors and enter it as a decimal integer in the box below.\nN = 17976931348623159077293051907890247336179769789423065727343008115 \\ 77326758055056206869853794492129829595855013875371640157101398586 \\ 47833778606925583497541085196591615128057575940752635007475935288 \\ 71082364994994077189561705436114947486504671101510156394068052754 \\ 0071584560878577663743040086340742855278549092581 For completeness, let us see why $A-\\sqrt{N}\u0026lt;1$. This follows from the following simple calculation. First observe that $A^2-N=\\left(\\frac{p+q}{2}\\right)^2-N=\\frac{p^2+2 N+q^2}{4}-N=\\frac{p^2-2 N+q^2}{4}=(p-q)^2 / 4$. Now, since for all $x, y: \\quad(x-y)(x+y)=x^2-y^2$ we obtain $A-\\sqrt{N}=(A-\\sqrt{N}) \\frac{A+\\sqrt{N}}{A+\\sqrt{N}}=$ $\\frac{A^2-N}{A+\\sqrt{N}}=\\frac{(p-q)^2 / 4}{A+\\sqrt{N}}$ Since $\\sqrt{N} \\leq A$ it follows that $A-\\sqrt{N} \\leq \\frac{(p-q)^2 / 4}{2 \\sqrt{N}}=\\frac{(p-q)^2}{8 \\sqrt{N}}$. By assumption (*) we know that $(p-q)^2\u0026lt;4 \\sqrt{N}$ and therefore $A-\\sqrt{N} \\leq \\frac{4 \\sqrt{N}}{8 \\sqrt{N}}=1 / 2$ as required.\n$0\u0026lt;A-\\sqrt{N}\u0026lt;1$$\\implies A\u0026lt;\\sqrt{N}+1$\n$\\text{proof:}$\n${A}=\\frac{p+q}{2}, {~N}={pq}$ $A$为整数\n对左边:\n$0\u0026lt;{A}-\\sqrt{N}$ : 由基本不等式 $\\sqrt{ab}\\leq\\frac{a+b}{2}$ 可以得到 $\\sqrt{pq}\u0026lt;\\frac{p+q}{2}$ 因为 $p\\neq q$ ，所以无法取到等号，所以 $\\sqrt{pq}\u0026lt;{A}$$\\implies 0\u0026lt;A-\\sqrt{N}$$\\implies\\sqrt{N}\u0026lt;{A}$\n对右边:\n$A-\\sqrt{N}\u0026lt;1$,有:\n$$ \\mathrm{A}^2-\\mathrm{N}=\\left(\\frac{\\mathrm{p}+\\mathrm{q}}{2}\\right)^2-\\mathrm{N}=\\frac{\\mathrm{p}^2+2 \\mathrm{~N}+\\mathrm{q}^2}{4}-\\mathrm{N}=\\frac{\\mathrm{p}^2-2 \\mathrm{~N}+\\mathrm{q}^2}{4}=\\frac{(\\mathrm{p}-\\mathrm{q})^2}{4}\\tag{1} $$ 对于 $A-\\sqrt{N}$ ，有: $$ A-\\sqrt{N}=\\frac{(A-\\sqrt{N})(A+\\sqrt{N})}{A+\\sqrt{N}}=\\frac{A^2-N}{A+\\sqrt{N}}={A+\\sqrt{N}}=\\frac{\\frac{(p-q)^2}{4}}{A+\\sqrt{N}} \\tag{1} $$ 由于 $\\sqrt{N}\u0026lt;A$ ，那么， $$ A-\\sqrt{\\mathrm{N}}=\\frac{\\frac{(\\mathrm{p}-\\mathrm{q})^2}4}{\\mathrm{~A}+\\sqrt{\\mathrm{N}}}\u0026lt;\\frac{\\frac{(\\mathrm{p}-\\mathrm{q})^2}4}{\\sqrt{\\mathrm{N}}+\\sqrt{\\mathrm{N}}}=\\frac{(\\mathrm{p}-\\mathrm{q})^2}{8 \\sqrt{\\mathrm{N}}} \\tag{3} $$ 由于challenge #1满足 $|p-q|\u0026lt;2 N^{1 / 4}$ ，即 $(p-q)^2\u0026lt;4 \\sqrt{N}$ ，最后得到: $$ \\mathrm{A}-\\sqrt{\\mathrm{N}}=\\frac{(\\mathrm{p}-\\mathrm{q})^2}{8 \\sqrt{\\mathrm{N}}}\u0026lt;\\frac{4 \\sqrt{\\mathrm{N}}}{8 \\sqrt{\\mathrm{N}}}=1 / 2\u0026lt;1 \\tag{4} $$\nEnter the answer for factoring challenge #1 in the box below:\n13407807929942597099574024998205846127479365820592393377723561443721764030073662768891111614362326998675040546094339320838419523375986027530441562135724301 code:\nimport gmpy2 def task1(): #初始化大整数n n =gmpy2.mpz(\u0026#39;17976931348623159077293051907890247336179769789423065727343008115\u0026#39; + \u0026#39;77326758055056206869853794492129829595855013875371640157101398586\u0026#39; + \u0026#39;47833778606925583497541085196591615128057575940752635007475935288\u0026#39; + \u0026#39;71082364994994077189561705436114947486504671101510156394068052754\u0026#39; + \u0026#39;0071584560878577663743040086340742855278549092581\u0026#39;) #得到n的平方根的整数部分 A,r=gmpy2.isqrt_rem(n)#A为整数部分，r为余数 if r\u0026gt;0: A+=1 #得到x x=gmpy2.isqrt(A**2-n) #得到p和q p,q=A-x,A+x #检验p和q是否为素数且p*q=n if gmpy2.is_prime(p) and gmpy2.is_prime(q) and gmpy2.mul(p,q)==n: print(\u0026#39;p=\u0026#39;,p) print(\u0026#39;q=\u0026#39;,q) if __name__ == \u0026#39;__main__\u0026#39;: task1() Factoring challenge #2: The following modulus $N$ is a products of two primes $p$ and $q$ where $|p-q|\u0026lt;2^{11} N^{1 / 4}$. Find the smaller of the two factors and enter it as a decimal integer.\nHint: in this case $A-\\sqrt{N}\u0026lt;2^{20}$ so try scanning for $A$ from $\\sqrt{N}$ upwards, until you succeed in factoring $N$.\n$\\text{Proof:}$\n由Factoring challenge #1的证明\n${A}=\\frac{p+q}{2}, {~N}={pq}$ $A$为整数\n$|p-q|\u0026lt;2^{11} N^{1 / 4}$$\\implies$$(p-q)^2\u0026lt;2^{22}\\sqrt{N}$\n由公式$3$可以得到 $$ 0\u0026lt;A-\\sqrt{\\mathrm{N}}=\\frac{\\frac{(\\mathrm{p}-\\mathrm{q})^2}4}{\\mathrm{~A}+\\sqrt{\\mathrm{N}}}\u0026lt;\\frac{\\frac{(\\mathrm{p}-\\mathrm{q})^2}4}{\\sqrt{\\mathrm{N}}+\\sqrt{\\mathrm{N}}}=\\frac{(\\mathrm{p}-\\mathrm{q})^2}{8 \\sqrt{\\mathrm{N}}}\u0026lt;\\frac{2^{22}\\sqrt{N}}{8\\sqrt{N}}=2^{19}\\tag{5} $$ 因此$A$的范围应该在$(\\sqrt{N},2^{19}+\\sqrt{N})$\nN =6484558428080716696628242653467722787263437207069762630604390703787 \\ 9730861808111646271401527606141756919558732184025452065542490671989 \\ 2428844841839353281972988531310511738648965962582821502504990264452 \\ 1008852816733037111422964210278402893076574586452336833570778346897 \\ 15838646088239640236866252211790085787877 Enter the answer for factoring challenge #2 in the box below:\n25464796146996183438008816563973942229341454268524157846328581927885777969985222835143851073249573454107384461557193173304497244814071505790566593206419759 Code\nimport gmpy2 def task2(): #初始化大整数n n =gmpy2.mpz(\u0026#39;6484558428080716696628242653467722787263437207069762630604390703787\u0026#39;+\u0026#39;9730861808111646271401527606141756919558732184025452065542490671989\u0026#39;+ \u0026#39;2428844841839353281972988531310511738648965962582821502504990264452\u0026#39;+\u0026#39;1008852816733037111422964210278402893076574586452336833570778346897 \u0026#39;+\u0026#39;15838646088239640236866252211790085787877\u0026#39;) #初始化得到n的平方根的整数部分 A=gmpy2.isqrt(n)+1#A为整数部分 向上取整A^2\u0026gt;n #循环次数 max_count=pow(2,20) #得到x for i in range(max_count): x,r=gmpy2.isqrt_rem(A**2-n) #得到p和q if r==0: p,q=A-x,A+x #检验p和q是否为素数且p*q=n if gmpy2.is_prime(p) and gmpy2.is_prime(q) and gmpy2.mul(p,q)==n: print(\u0026#39;[!] Found it count=\u0026#39;,i) print(\u0026#39;p=\u0026#39;,p) print(\u0026#39;q=\u0026#39;,q) break A+=1 if __name__ == \u0026#39;__main__\u0026#39;: task2() Factoring challenge #3: The following modulus $N$ is a product of two primes $p$ and $q$ where $|3 p-2 q|\u0026lt;N^{1 / 4}$. Find the smaller of the two factors and enter it as a decimal integer. Hint: first show that $\\sqrt{6 N}$ is close to $\\frac{3 p+2 q}{2}$ and then adapt the method in challenge #1 to factor $N$.\nN =72006226374735042527956443552558373833808445147399984182665305798191 \\ 63556901883377904234086641876639384851752649940178970835240791356868 \\ 77441155132015188279331812309091996246361896836573643119174094961348 \\ 52463970788523879939683923036467667022162701835329944324119217381272 \\ 9276147530748597302192751375739387929 $A-\\sqrt{6N}\u0026lt;\\frac{1}{8\\sqrt{6}}$\n$\\text{Proof:}$\n定义$A=\\frac{3p+2q}{2}$即$A$是$3p$和$2q$的中点，且$3p$是奇数,$2q$是偶数，所以$A$一定不是整数\n由challenge #1同理\n$\\because $$\\text{A是3p,2q的中点}$\n$\\therefore$ $p=\\frac{A-x}{3}$ $q=\\frac{A+x}{2}$$\\implies N=p q=\\frac{(A-x)(A+x)}{6}=\\frac{A^2-x^2}{6}$(这里其实$\\frac{A-x}{3}$有可能为p或者q,还要根据$A-x$是否被3除尽就可确定)\n$\\therefore x=\\sqrt{A^2-6N}$\n所以得到$x$的值可以得到$p,q$的取值\n由$\\sqrt{ab}\u0026lt;=\\frac{a+b}{2}$\n$\\therefore{\\sqrt{6pq}\u0026lt;\\frac{3p+2q}{2}}$$\\implies \\sqrt{6N}\u0026lt;A$\n$$ A-\\sqrt{6N}=\\frac{A^2-6N}{A+\\sqrt{6N}}=\\frac{\\frac{(3p-2q)^2}{4}}{A+\\sqrt{6N}}\u0026lt;\\frac{\\frac{(3p-2q)^2}{4}}{\\sqrt{6N}+\\sqrt{6N}}=\\frac{\\frac{(3p-2q)^2}{4}}{2\\sqrt{6N}} \\tag {6} $$ 由于challenge3满足$|3 p-2 q|\u0026lt;N^{1 / 4}$即是$(3p-2q)^2\u0026lt;\\sqrt{N}$ $$ A-\\sqrt{6N}\u0026lt;\\frac{\\frac{(3p-2q)^2}{4}}{2\\sqrt{6N}}\u0026lt;\\frac{1}{8\\sqrt{6}} $$\nEnter the answer for factoring challenge #3 in the box below:\n21909849592475533092273988531583955898982176093344929030099423584127212078126150044721102570957812665127475051465088833555993294644190955293613411658629209 code\nfrom decimal import Decimal, getcontext def isqrt(n): x = n y = (x + 1) // 2 while y \u0026lt; x: x = y y = (x + n // x) // 2 return x def task3(): n=720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929 getcontext().prec=350#设置精度 A=Decimal(isqrt(6*n))+Decimal(0.5) while True: x=Decimal(A**2-6*Decimal(n)).sqrt() p=int(A-x) q=int(A+x) if p*q==6*n: if p%3==0 and q%2==0: p//=3 q//=2 break if p%2==0 and q%3==0: p//=2 q//=3 break A+=1 print(p) print(q) if __name__ == \u0026#39;__main__\u0026#39;: task3() 4. The challenge ciphertext provided below is the result of encrypting a short secret ASCII plaintext using the RSA modulus given in the first factorization challenge.\nThe encryption exponent used is $e=65537$ The ASCII plaintext was encoded using PKCS v1.5 before the RSA function was applied, as described in PKCS.\nUse the factorization you obtained for this RSA modulus to decrypt this challenge ciphertext and enter the resulting English plaintext in the box below. Recall that the factorization of $N$ enables you to compute $\\varphi(N)$from which you can obtain the RSA decryption exponent.\nChallenge ciphertext (as a decimal integer): 22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540 After you use the decryption exponent to decrypt the challenge ciphertext you will obtain a PKCS1 encoded plaintext.To undo the encoding it is best to write the decrypted value in hex.You will observe that the number starts with a \u0026lsquo;0x02\u0026rsquo; followed by many random non-zero digits.Look for the \u0026lsquo;0x00\u0026rsquo; separator and the digits following this separator are the ASCII letters of the plaintext.\n(note: the separator used here is \u0026lsquo;0x00\u0026rsquo;, not \u0026lsquo;0xFF\u0026rsquo; as stated in the lecture)\n公钥就是 N，e 而 私钥就是N，d 加密 m^e ≡ c (mod n) 解密 c^d ≡ m (mod n) import binascii import gmpy2 def task4(): c = gmpy2.mpz(\u0026#39;22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256\u0026#39; + \u0026#39;46583996794288946076454204058156474898801373486412045232522932017648791666640299750918872997169052608322206777160001932\u0026#39; + \u0026#39;9260870009579993724077458967773697817571267229951148662959627934791540\u0026#39;) n = gmpy2.mpz(\u0026#39;17976931348623159077293051907890247336179769789423065727343008115\u0026#39; + \u0026#39;77326758055056206869853794492129829595855013875371640157101398586\u0026#39; + \u0026#39;47833778606925583497541085196591615128057575940752635007475935288\u0026#39; + \u0026#39;71082364994994077189561705436114947486504671101510156394068052754\u0026#39; + \u0026#39;0071584560878577663743040086340742855278549092581\u0026#39;) e =gmpy2.mpz(65537) a = gmpy2.isqrt(n) + 1 x = gmpy2.isqrt(a**2 - n) p = a - x q = a + x fi = (p-1) * (q-1)#欧拉函数 d = gmpy2.invert(e, fi)#求e的模fi的逆元 r = gmpy2.powmod(c, d, n)#求c的d次方模n #PKCS解密 m = gmpy2.digits(r, 16).split(\u0026#39;00\u0026#39;)[1]#将r转换为16进制，然后以00为分隔符分割，取第二个元素 return binascii.unhexlify(m.encode(\u0026#39;utf-8\u0026#39;)) if __name__ == \u0026#39;__main__\u0026#39;: print(task4()) Factoring lets us break RSA. 参考博客 实验四 RSA中公开的模数N_chuxuezheerer的博客-CSDN博客_rsa 模数\n","permalink":"https://niceasiv.cn/posts/week6-quiz/","summary":"Content 更好的效果PDF:pdf文章列表 | Asiv\u0026rsquo;s Blog (niceasiv.cn)\nFactoring challenge #1: Your goal in this project is to break RSA when the public modulus $N$ is generated incorrectly. This should serve as yet another reminder not to implement crypto primitives yourself.\nNormally, the primes that comprise an RSA modulus are generated independently of one another. But suppose a developer decides to generate the first prime $p$ by choosing a random number $R$ and scanning for a prime close by. The second prime $q$ is generated by scanning for some other random prime also close to $R$. We show that the resulting RSA modulus $N=p q$ can be easily factored.\n在公开的N没有被正确的生成时破解RSA。通常在RSA中构成模数N的素数q和p,应该独立生成。如果开发者使用一个随机数R,并选择R附近的两个素数作为q和p，那么这种情况情况下生成的RSA模数N就很容易被破解。\nSuppose you are given a composite(合数) $N$ and are told that $N$ is a product of two relatively close primes $p$ and $q$, namely $p$ and $q$ satisfy $$ |p-q|\u0026lt;2 N^{1 / 4} $$ Your goal is to factor $N$.","title":"Week 6 - Programming Assignment"},{"content":" Humoooor\rFree to Hack\rWking\rEnjoy your life for yourself!\r","permalink":"https://niceasiv.cn/friends/","summary":" Humoooor\rFree to Hack\rWking\rEnjoy your life for yourself!\r","title":"朋友们"},{"content":"","permalink":"https://niceasiv.cn/posts/cve20200601/","summary":"","title":"CVE2020-06-01复现"},{"content":"数据类型 字符串类 删除空白\nrstrip 删除右边空格\nlstrip 删除左边空格\nstrip 删除两边空格\nIn [1]: str=\u0026#34; python \u0026#34; In [2]: str.rstrip() Out[2]: \u0026#39; python\u0026#39; In [3]: str.lstrip() Out[3]: \u0026#39;python \u0026#39; In [4]: str.strip() Out[4]: \u0026#39;python\u0026#39; 列表 列表的索引从0开始\n元素添加和删除 1.在列表末尾添加元素\nIn [5]: bicycles = [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [6]: bicycles[1] Out[6]: \u0026#39;cannondale\u0026#39; In [7]: bicycles.append(\u0026#34;app\u0026#34;) In [8]: bicycles Out[8]: [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;, \u0026#39;app\u0026#39;] 2.在列表任意位置插入元素\nIn [9]: bicycles.insert(0,\u0026#34;app\u0026#34;) In [10]: bicycles Out[10]: [\u0026#39;app\u0026#39;, \u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;, \u0026#39;app\u0026#39;] 3.从列表末尾或任意位置删除元素\npop()会返回弹出的元素\nIn [11]: bicycles.pop() Out[11]: \u0026#39;app\u0026#39; In [12]: bicycles Out[12]: [\u0026#39;app\u0026#39;, \u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [14]: bicycles Out[14]: [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [15]: bicycles.pop(0) Out[15]: \u0026#39;trek\u0026#39; 4.从列表删除任意位置元素\nIn [12]: bicycles Out[12]: [\u0026#39;app\u0026#39;, \u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [13]: del bicycles[0] In [14]: bicycles Out[14]: [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] 5.删除指定值\nremove()\nIn [18]: bicycles Out[18]: [\u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [19]: bicycles.remove(\u0026#39;redline\u0026#39;) In [20]: bicycles Out[20]: [\u0026#39;cannondale\u0026#39;, \u0026#39;specialized\u0026#39;] 元素排序 1.sort(*, key=None, reverse=False)永久性排序\nIn [26]: num=[1,3,2,4] In [27]: num.sort() In [28]: num Out[28]: [1, 2, 3, 4] 2.sorted(iterable, /, *, key=None, reverse=False)暂时性排序\nIn [1]: app=[\u0026#39;A\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;B\u0026#39;] In [2]: sorted(app) Out[2]: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] 列表操作 列表解析\n要使用这种语法，首先指定一个描述性的列表名；然后，指定一个左方括号， 并定义一个表达式，用于生成你要存储到列表中的值。\nIn [3]: values=[_**2 for _ in range(1,11)] In [4]: values Out[4]: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 复制\nt1=values t2=values[:] In [16]: t1 Out[16]: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] In [17]: t2 Out[17]: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] In [18]: values[2]=3 In [19]: t1 Out[19]: [1, 4, 3, 16, 25, 36, 49, 64, 81, 100] In [20]: t2 Out[20]: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 元组 元组其实跟列表差不多，也是存一组数，只不是它一旦创建，便不能再修改，所以又叫只读列表\n元组使用小括号，列表使用方括号\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可\n用途：一般情况下用于自己写的程序能存下数据，但是又希望这些数据不会被改变，比如：数据库连接信息等\n#元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例: \u0026gt;\u0026gt;\u0026gt; tup1 = (12, 34.56); \u0026gt;\u0026gt;\u0026gt; tup2 = (\u0026#39;abc\u0026#39;, \u0026#39;xyz\u0026#39;) # 以下修改元组元素操作是非法的。 # tup1[0] = 100 # 创建一个新的元组 \u0026gt;\u0026gt;\u0026gt; tup3 = tup1 + tup2; \u0026gt;\u0026gt;\u0026gt; print (tup3) (12, 34.56, \u0026#39;abc\u0026#39;, \u0026#39;xyz\u0026#39;) 虽然不能修改元组的元素，但是可以给存储元组的变量赋值\n字典 删除键值对\ndel() In [25]: dic Out[25]: {\u0026#39;a\u0026#39;: 1} In [26]: del dic[\u0026#39;a\u0026#39;] In [27]: dic Out[27]: {} 遍历字典\nIn [36]: for name,value in dic.items(): ...: print(name) ...: a b c In [37]: for name,value in dic.items(): ...: print(value) ...: 1 2 3 In [38]: for _ in dic.items(): ...: print(_) ...: (\u0026#39;a\u0026#39;, 1) (\u0026#39;b\u0026#39;, 2) (\u0026#39;c\u0026#39;, 3) 函数 传递实参 位置实参\n调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此， 最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。\ndef describe_pet(animal_type, pet_name): \u0026#34;\u0026#34;\u0026#34;显示宠物的信息\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;\\nI have a \u0026#34; + animal_type + \u0026#34;.\u0026#34;) print(\u0026#34;My \u0026#34; + animal_type + \u0026#34;\u0026#39;s name is \u0026#34; + pet_name.title() + \u0026#34;.\u0026#34;) describe_pet(\u0026#39;hamster\u0026#39;, \u0026#39;harry\u0026#39;) 位置实参的顺序对函数的运行很重要\n关键字实参 关键字实参是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆\ndef describe_pet(animal_type, pet_name): \u0026#34;\u0026#34;\u0026#34;显示宠物的信息\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;\\nI have a \u0026#34; + animal_type + \u0026#34;.\u0026#34;) print(\u0026#34;My \u0026#34; + animal_type + \u0026#34;\u0026#39;s name is \u0026#34; + pet_name.title() + \u0026#34;.\u0026#34;) describe_pet(animal_type=\u0026#39;hamster\u0026#39;, pet_name=\u0026#39;harry\u0026#39;) Q:让实参变为可选\n可给实参指定一个默认值——空字符串\n传递任意数量的实参\ndef make_pizza(*toppings): \u0026#34;\u0026#34;\u0026#34;打印顾客点的所有配料\u0026#34;\u0026#34;\u0026#34; print(toppings) make_pizza(\u0026#39;pepperoni\u0026#39;) make_pizza(\u0026#39;mushrooms\u0026#39;, \u0026#39;green peppers\u0026#39;, \u0026#39;extra cheese\u0026#39;) 形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封装到这个元组中。\n面向对象OOP 根据约定，在Python中首字母大写的是类\n使用isinstance来测试一个对象是否为某个类的实例\n方法__init__初始化方法\nclass Dog(): \u0026#39;\u0026#39;\u0026#39;A simple attempt to model a dog.\u0026#39;\u0026#39;\u0026#39; def __init__(self,name,age): self.name=name self.age=age def sit(self): print(self.name.title() + \u0026#34; is now sitting.\u0026#34;) def roll_over(self): print(self.name.title() + \u0026#34; rolled over!\u0026#34;) my_dog=Dog(\u0026#39;willie\u0026#39;,6) my_dog.sit() 每个与类相关联的方法 调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。\n我们将通过实参向Dog()传递名字和 年龄；self会自动传递，因此我们不需要传递它。每当我们根据Dog类创建实例时，都只需给最 后两个形参（name和age）提供值。\n继承 class Car(): def __init__(self, make, model, year) class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;Represent aspects of a car, specific to electric vehicles.\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34; 电动汽车的独特之处 初始化父类的属性，再初始化电动汽车特有的属性 \u0026#34;\u0026#34;\u0026#34; super(ElectricCar,self).__init__(make, model, year) #初始化父类方法 self.battery_size = 70 重写父类方法\n直接定义覆盖父类的函数即可,Python将忽略父类中的同名方法\ntodo :列表推导式\n","permalink":"https://niceasiv.cn/posts/pythonnote/","summary":"数据类型 字符串类 删除空白\nrstrip 删除右边空格\nlstrip 删除左边空格\nstrip 删除两边空格\nIn [1]: str=\u0026#34; python \u0026#34; In [2]: str.rstrip() Out[2]: \u0026#39; python\u0026#39; In [3]: str.lstrip() Out[3]: \u0026#39;python \u0026#39; In [4]: str.strip() Out[4]: \u0026#39;python\u0026#39; 列表 列表的索引从0开始\n元素添加和删除 1.在列表末尾添加元素\nIn [5]: bicycles = [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [6]: bicycles[1] Out[6]: \u0026#39;cannondale\u0026#39; In [7]: bicycles.append(\u0026#34;app\u0026#34;) In [8]: bicycles Out[8]: [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;, \u0026#39;app\u0026#39;] 2.在列表任意位置插入元素\nIn [9]: bicycles.insert(0,\u0026#34;app\u0026#34;) In [10]: bicycles Out[10]: [\u0026#39;app\u0026#39;, \u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;, \u0026#39;app\u0026#39;] 3.从列表末尾或任意位置删除元素\npop()会返回弹出的元素\nIn [11]: bicycles.pop() Out[11]: \u0026#39;app\u0026#39; In [12]: bicycles Out[12]: [\u0026#39;app\u0026#39;, \u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [14]: bicycles Out[14]: [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [15]: bicycles.pop(0) Out[15]: \u0026#39;trek\u0026#39; 4.从列表删除任意位置元素\nIn [12]: bicycles Out[12]: [\u0026#39;app\u0026#39;, \u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [13]: del bicycles[0] In [14]: bicycles Out[14]: [\u0026#39;trek\u0026#39;, \u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] 5.删除指定值\nremove()\nIn [18]: bicycles Out[18]: [\u0026#39;cannondale\u0026#39;, \u0026#39;redline\u0026#39;, \u0026#39;specialized\u0026#39;] In [19]: bicycles.remove(\u0026#39;redline\u0026#39;) In [20]: bicycles Out[20]: [\u0026#39;cannondale\u0026#39;, \u0026#39;specialized\u0026#39;] 元素排序 1.","title":"Python复习"},{"content":"为了理解蒸馏的含义，我们先以DQN为例\nDQN（Deep Q-Network）是一种强化学习算法，它通过深度神经网络来近似Q函数，从而实现智能体的行为决策。下面我们将介绍一个针对DQN网络的案例。\n假设我们有一个小型的迷宫环境，智能体的任务是通过左、右、上、下四个动作来找到宝藏并获得最高的奖励。我们可以使用DQN算法来训练智能体。\n首先，我们需要定义状态空间、动作空间、奖励函数以及转移函数。在这个案例中，状态空间是迷宫中每个位置的坐标，动作空间是四个方向，奖励函数是在找到宝藏时获得的奖励，转移函数是在智能体执行一个动作后转移到下一个状态的过程。\n然后，我们可以使用深度神经网络来近似Q函数。在这个案例中，我们可以使用一个简单的全连接神经网络，它的输入是当前状态，输出是四个动作的Q值。我们使用均方误差损失函数来度量Q值的预测误差，并使用梯度下降算法来优化神经网络参数。\n接下来，我们可以使用经验回放机制来训练DQN网络。经验回放是一种存储智能体的经验，并从中随机抽样的机制。这样可以使得训练数据更加丰富、稳定，并且可以避免连续的训练样本之间的相关性。在每次训练中，我们随机从经验池中选择一个批次的样本，然后用它来更新神经网络参数。\n最后，我们可以通过迭代训练来提高DQN网络的性能。我们通过不断地与环境交互、收集经验、更新神经网络参数来提高DQN网络的预测性能。在训练的过程中，我们可以使用ε-greedy策略来平衡探索和利用，这样可以使得智能体在探索新状态和利用已有知识之间找到一个平衡点。\n通过以上的训练过程，我们可以得到一个训练好的DQN网络，它可以在迷宫环境中通过左、右、上、下四个动作来找到宝藏并获得最高的奖励。\n下面是一个基于DQN算法的伪代码：\n初始化神经网络 Q(s,a;θ) 的参数 θ 初始化目标网络 Q\u0026rsquo;(s,a;θ^-) 的参数 θ^-\n初始化经验池 D\nfor episode = 1 to M do: 初始化状态 s for t = 1 to T do: 选择动作 a ： 如果随机数小于 ε，则选择一个随机动作 否则，选择 a = argmax Q(s,a;θ) 执行动作 a 并观察下一个状态 s\u0026#39; 和奖励 r 存储经验 (s, a, r, s\u0026#39;) 到经验池 D 从经验池 D 中随机抽取一个批次的经验 (s_i, a_i, r_i, s\u0026#39;_i) 对于批次中的每个样本 (s_i, a_i, r_i, s\u0026#39;_i) ，计算目标 Q 值： 如果 s\u0026#39;_i 是终止状态，则 Q_target = r_i 否则，Q_target = r_i + γ max Q\u0026#39;(s\u0026#39;_i, a\u0026#39;;θ^-) 使用 Q(s_i, a_i;θ) 和 Q_target 之间的均方误差来更新神经网络 Q(s,a;θ) 的参数 θ 如果 t mod C == 0，那么将目标网络的参数 θ^- 更新为 Q(s,a;θ) 的参数 θ 将状态更新为 s\u0026#39; 减小 ε 保存神经网络 Q(s,a;θ) 的参数 θ 其中，M 是迭代训练的次数，T 是每个 episode 的最大步数，ε 是 ε-greedy 策略中的探索率，γ 是折扣因子，C 是更新目标网络的间隔，D 是经验池，Q 和 Q\u0026rsquo; 分别是当前网络和目标网络。\n","permalink":"https://niceasiv.cn/posts/policy_distillation/","summary":"为了理解蒸馏的含义，我们先以DQN为例\nDQN（Deep Q-Network）是一种强化学习算法，它通过深度神经网络来近似Q函数，从而实现智能体的行为决策。下面我们将介绍一个针对DQN网络的案例。\n假设我们有一个小型的迷宫环境，智能体的任务是通过左、右、上、下四个动作来找到宝藏并获得最高的奖励。我们可以使用DQN算法来训练智能体。\n首先，我们需要定义状态空间、动作空间、奖励函数以及转移函数。在这个案例中，状态空间是迷宫中每个位置的坐标，动作空间是四个方向，奖励函数是在找到宝藏时获得的奖励，转移函数是在智能体执行一个动作后转移到下一个状态的过程。\n然后，我们可以使用深度神经网络来近似Q函数。在这个案例中，我们可以使用一个简单的全连接神经网络，它的输入是当前状态，输出是四个动作的Q值。我们使用均方误差损失函数来度量Q值的预测误差，并使用梯度下降算法来优化神经网络参数。\n接下来，我们可以使用经验回放机制来训练DQN网络。经验回放是一种存储智能体的经验，并从中随机抽样的机制。这样可以使得训练数据更加丰富、稳定，并且可以避免连续的训练样本之间的相关性。在每次训练中，我们随机从经验池中选择一个批次的样本，然后用它来更新神经网络参数。\n最后，我们可以通过迭代训练来提高DQN网络的性能。我们通过不断地与环境交互、收集经验、更新神经网络参数来提高DQN网络的预测性能。在训练的过程中，我们可以使用ε-greedy策略来平衡探索和利用，这样可以使得智能体在探索新状态和利用已有知识之间找到一个平衡点。\n通过以上的训练过程，我们可以得到一个训练好的DQN网络，它可以在迷宫环境中通过左、右、上、下四个动作来找到宝藏并获得最高的奖励。\n下面是一个基于DQN算法的伪代码：\n初始化神经网络 Q(s,a;θ) 的参数 θ 初始化目标网络 Q\u0026rsquo;(s,a;θ^-) 的参数 θ^-\n初始化经验池 D\nfor episode = 1 to M do: 初始化状态 s for t = 1 to T do: 选择动作 a ： 如果随机数小于 ε，则选择一个随机动作 否则，选择 a = argmax Q(s,a;θ) 执行动作 a 并观察下一个状态 s\u0026#39; 和奖励 r 存储经验 (s, a, r, s\u0026#39;) 到经验池 D 从经验池 D 中随机抽取一个批次的经验 (s_i, a_i, r_i, s\u0026#39;_i) 对于批次中的每个样本 (s_i, a_i, r_i, s\u0026#39;_i) ，计算目标 Q 值： 如果 s\u0026#39;_i 是终止状态，则 Q_target = r_i 否则，Q_target = r_i + γ max Q\u0026#39;(s\u0026#39;_i, a\u0026#39;;θ^-) 使用 Q(s_i, a_i;θ) 和 Q_target 之间的均方误差来更新神经网络 Q(s,a;θ) 的参数 θ 如果 t mod C == 0，那么将目标网络的参数 θ^- 更新为 Q(s,a;θ) 的参数 θ 将状态更新为 s\u0026#39; 减小 ε 保存神经网络 Q(s,a;θ) 的参数 θ 其中，M 是迭代训练的次数，T 是每个 episode 的最大步数，ε 是 ε-greedy 策略中的探索率，γ 是折扣因子，C 是更新目标网络的间隔，D 是经验池，Q 和 Q\u0026rsquo; 分别是当前网络和目标网络。","title":"策略蒸馏"},{"content":"基础 马尔科夫决策(MDP) 在随机过程中某时刻$t$的状态用$S_t$表示，所以可能的状态组成了状态空间$S$。\n如果已知历史的状态信息即$(S_1,\u0026hellip;,S_t)$,那么下一个时刻状态为$S_{t+1}$的概率为$P(S_{t+1}\\mid S_1,\u0026hellip;,S_t)$\n当且仅当某时刻的状态只取决于上一时刻的状态时，一个随机过程被称为具有马尔可夫性质\n$$ P(S_{t+1}\\mid S_t)=P(S_{t+1}\\mid S_1,\u0026hellip;,S_t) $$ 也就是说当前状态是未来的充分统计量，即下一个状态只取决于当前状态，而不会受到过去状态的影响。\n注意：\n虽然$t+1$时刻的状态只与$t$时刻的状态有关，但是$t$时刻的状态其实包含了$t-1$时刻的状态的信息，通过这种链式的关系，历史的信息被传递到了现在。\nMarkov process 通常用两元组$\u0026lt;S,P\u0026gt;$描述一个马尔科夫过程，其中$S$是有限状态集合，$P$是状态转移矩阵\n矩阵$P$中第$i$行第$j$列$P(s_j|s_i)$表示状态$s_i$转移到状态$s_j$的概率，从某个状态出发，到达其他状态的概率和必须为1，即状态转移矩阵的每一行的和为1。\n给定一个马尔可夫过程，我们就可以从某个状态出发，根据它的状态转移矩阵生成一个状态序列（episode），这个步骤也被叫做采样（sampling）。\nMarkov reward process(MRP) 一个马尔科夫奖励过程由$\\langle \\mathcal{S},\\mathcal{P},r,\\gamma \\rangle$\n$\\mathcal{S}$ 是有限状态的集合。 $\\mathcal{P}$ 是状态转移矩阵。 $r$是奖励函数,某个状态$s$的奖励$r(s)$指转移到该状态时可以获得奖励的期望。 $\\gamma$ 是折扣因子,$\\gamma$的取值为$[0,1)$ 。引入折扣因子的理由为远期利益具有一定不确定性，有时我们更希望能够尽快获得一些奖励，所以我们需要对远期利益打一些折扣。接近 1 的 $\\gamma$ 更关注长期的累计奖励，接近0的$\\gamma$ 更考虑短期奖励。 奖励函数的本质:向智能体传达目标(MDP) 强化学习的标准交互过程如下：每个时刻，智能体根据根据其 策略(policy)，在当前所处 状态(state) 选择一个 动作(action)，环境(environment) 对这些动作做出相应的相应的响应，转移到新状态，同时产生一个 奖励信号 (reward)，这通常是一个数值，奖励的折扣累加和称为 收益/回报 (return)，是智能体在动作选择过程中想要最大化的目标\n“奖励 \u0026amp; 收益” 其实是智能体目标的一种形式化、数值化的表征。可以把这种想法非正式地表述为 “收益假设” 收益是通过奖励信号计算的，而奖励函数是我们提供的，奖励函数起到了人与算法沟通的桥梁作用 需要注意的是，智能体只会学习如何最大化收益，如果想让它完成某些指定任务，就必须保证我们设计的奖励函数可以使得智能体最大化收益的同时也能实现我们的目标 回报 在一个马尔可夫奖励过程中，从第$t$时刻状态$S_t$开始，直到终止状态时，所有奖励的衰减之和称为回报（Return）\n假设设置$\\gamma =0.5$\n$$ G_t=R_t+\\gamma R_{t+1}+\\gamma^2 R_{t+2}+\\cdots=\\sum_{k=0}^{\\infty} \\gamma^k R_{t+k} $$ 假设路径为1,2,3,6\nimport numpy as np np.random.seed(0) #概率转移矩阵 P=[ [0.9,0.1,0.0,0.0,0.0,0.0], [0.5,0.0,0.5,0.0,0.0,0.0], [0.0,0.0,0.0,0.6,0.0,0.4], [0.0,0.0,0.0,0.0,0.3,0.7], [0.0,0.2,0.3,0.5,0.0,0.0], [0.0,0.0,0.0,0.6,0.0,1.0], ] P=np.array(P) rewards=[-1,-2,-2,10,1,0] gamma=0.5 def compute_chain_reward(start_index,chain,gamma): reward=0 for i in range(len(chain)): reward=gamma*reward+rewards[chain[i]-1] return reward chain=[1,2,3,6] start_index=0 reward=compute_chain_reward(start_index,chain,gamma) print(reward) 状态价值函数 一个状态的期望回报(即从这个状态出发的未来累积奖励的期望)-\u0026gt;价值\n即其状态价值函数$V_{\\pi}(s)$就等于转移到每个通路上的概率（由策略决定）乘以每条路上得到的回报即\n$V(s)=\\mathbb{E}\\left[G_t \\mid S_t=s\\right]$\n展开为: $$ \\begin{align} V(s) \u0026amp;=\\mathbb{E}[G_t \\mid S_t=s] \\ \u0026amp;=\\mathbb{E}[R_t+\\gamma R_{t+1}+\\gamma^2 R_{t+2}+\u0026hellip;\\mid S_t=s]\\ \u0026amp;=\\mathbb{E}[R_t+\\gamma(R_{t+1}+\\gamma R_{t+2})+\u0026hellip; \\mid S_t=s]\\ \u0026amp;=\\mathbb{E}[R_t+\\gamma G_{t+1}\\mid S_t=s]\\ \u0026amp;=\\mathbb{E}[R_t+\\gamma V(S_{t+1})\\mid S_t=s]\\ \\end{align} $$ 一方面,即时奖励的期望正是奖励函数的输出，即：\n$\\mathbb{E}\\left[R_t \\mid S_t=s\\right]=r(s)$\n另一方面，等式中剩余部分 $\\mathbb{E}\\left[\\gamma V\\left(S_{t+1}\\right) \\mid S_t=s\\right]$ 可以根据从状态$s$出发的转移概率得到，即可以得到 $$ V(s)=r(s)+\\gamma\\sum_{s^{\\prime} \\in S }{p(s^{\\prime} \\mid s)V(s^\\prime)} $$ 上式就是马尔可夫奖励过程中非常有名的贝尔曼方程 (Bellman equation)，对每一个状态都成立。\n上式就是马尔可夫奖励过程中非常有名的贝尔曼方程 (Bellman equation)，对每一个状态都成立。\n若一个马尔可夫奖励过程一共有 $n$ 个状 态，即 $\\mathcal{S}=\\left{s_1, s_2, \\ldots, s_n\\right}$ ，我们将所有状态的价值表示成一个列向量 $\\mathcal{V}=\\left[V\\left(s_1\\right), V\\left(s_2\\right), \\ldots, V\\left(s_n\\right)\\right]^T$ ，同理，将奖励函数写成一个列向量 $\\mathcal{R}=\\left[r\\left(s_1\\right), r\\left(s_2\\right), \\ldots, r\\left(s_n\\right)\\right]^T$ 。于是我们可以将贝尔曼方程写成矩阵的形式: $$ \\begin{gathered} \\mathcal{V}=\\mathcal{R}+\\gamma \\mathcal{P} \\mathcal{V} \\ {\\left[\\begin{array}{c} V\\left(s_1\\right) \\ V\\left(s_2\\right) \\ \\ldots \\ V\\left(s_n\\right) \\end{array}\\right]=\\left[\\begin{array}{c} r\\left(s_1\\right) \\ r\\left(s_2\\right) \\ \\ldots \\ r\\left(s_n\\right) \\end{array}\\right]+\\gamma\\left[\\begin{array}{cccc} P\\left(s_1 \\mid s_1\\right) \u0026amp; p\\left(s_2 \\mid s_1\\right) \u0026amp; \\ldots \u0026amp; P\\left(s_n \\mid s_1\\right) \\ P\\left(s_1 \\mid s_2\\right) \u0026amp; P\\left(s_2 \\mid s_2\\right) \u0026amp; \\ldots \u0026amp; P\\left(s_n \\mid s_2\\right) \\ \\ldots \u0026amp; \u0026amp; \u0026amp; \\ P\\left(s_1 \\mid s_n\\right) \u0026amp; P\\left(s_2 \\mid s_n\\right) \u0026amp; \\ldots \u0026amp; P\\left(s_n \\mid s_n\\right) \\end{array}\\right]\\left[\\begin{array}{c} V\\left(s_1\\right) \\ V\\left(s_2\\right) \\ \\ldots \\ V\\left(s_n\\right) \\end{array}\\right]} \\end{gathered} $$ 我们可以直接根据矩阵运算求解，得到以下解析解: $$ \\begin{aligned} \\mathcal{V} \u0026amp; =\\mathcal{R}+\\gamma \\mathcal{P} \\mathcal{V} \\ (I-\\gamma \\mathcal{P}) \\mathcal{V} \u0026amp; =\\mathcal{R} \\ \\mathcal{V} \u0026amp; =(I-\\gamma \\mathcal{P})^{-1} \\mathcal{R} \\end{aligned} $$\ndef compute_state_value(P,rewards,gamma,states_num): rewards=np.array(rewards).reshape((-1,1)) value=np.dot(np.linalg.inv(np.eye(states_num)-gamma*P),rewards) return value state_value=compute_state_value(P,rewards,gamma,6) print(state_value) 动作价值函数 我们用 $Q^\\pi(s, a)$ 表示在 MDP 遵循策略 $\\pi$ 时，对当前状态 $s$ 执行动作 $a$ 得到的期望回报: $$ Q^\\pi(s, a)=\\mathbb{E}\\pi\\left[G_t \\mid S_t=s, A_t=a\\right] $$ 状态价值函数和动作价值函数之间的关系：在使用策略 $\\pi$ 中，状态 $s$ 的价值等于在该状态下基于策略 $\\pi$ 采取所有动作的概率与相应的价值相乘 再求和的结果: $$ V^\\pi(s)=\\sum{a \\in A} \\pi(a \\mid s) Q^\\pi(s, a) $$ 使用策略 $\\pi$ 时，状态 $s$ 下采取动作 $a$ 的价值等于即时奖励加上经过衰减后的所有可能的下一个状态的状态转移概率与相应的价值的乘积: $$ Q^\\pi(s, a)=r(s, a)+\\gamma \\sum_{s^{\\prime} \\in S} P\\left(s^{\\prime} \\mid s, a\\right) V^\\pi\\left(s^{\\prime}\\right) $$\n贝尔曼期望方程 $$ \\begin{aligned} V^\\pi(s) \u0026amp; =\\mathbb{E}\\pi\\left[R_t+\\gamma V^\\pi\\left(S{t+1}\\right) \\mid S_t=s\\right] \\ \u0026amp; =\\sum_{a \\in A} \\pi(a \\mid s)\\left(r(s, a)+\\gamma \\sum_{s^{\\prime} \\in S} p\\left(s^{\\prime} \\mid s, a\\right) V^\\pi\\left(s^{\\prime}\\right)\\right) \\ \\end{aligned} $$\n$$ \\begin{aligned} Q^\\pi(s, a) \u0026amp; =\\mathbb{E}\\pi\\left[R_t+\\gamma Q^\\pi\\left(S{t+1}, A_{t+1}\\right) \\mid S_t=s, A_t=a\\right] \\ \u0026amp; =r(s, a)+\\gamma \\sum_{s^{\\prime} \\in S} p\\left(s^{\\prime} \\mid s, a\\right) \\sum_{a^{\\prime} \\in A} \\pi\\left(a^{\\prime} \\mid s^{\\prime}\\right) Q^\\pi\\left(s^{\\prime}, a^{\\prime}\\right) \\end{aligned} $$\nMDP $\\langle \\mathcal{S},\\mathcal{A},P,r,\\gamma \\rangle$\n$\\mathcal{S}$是状态集合\n$\\mathcal{A}$ 是动作的集合；\n$\\gamma$ 是折扣因子;\n$r(s, a)$ 是奖励函数，此时奖励可以同时取决于状态 $s$ 和动作 $a$ ，在奖励函数 只取决于状态 $s$ 时，则退化为 $r(s)$ ；\n$P\\left(s^{\\prime} \\mid s, a\\right)$ 是状态转移函数，表示在状态 $s$ 执行动作 $a$ 之后到达状态 $s^{\\prime}$ 的概 率。\n#mdp过程 state=[\u0026#39;s1\u0026#39;,\u0026#39;s2\u0026#39;,\u0026#39;s3\u0026#39;,\u0026#39;s4\u0026#39;,\u0026#39;s5\u0026#39;,\u0026#39;s6\u0026#39;] action=[\u0026#39;s1-\u0026gt;s1\u0026#39;,\u0026#39;s1-\u0026gt;s2\u0026#39;,\u0026#39;s2-\u0026gt;s1\u0026#39;,\u0026#39;s2-\u0026gt;s3\u0026#39;,\u0026#39;s3-\u0026gt;s4\u0026#39;,\u0026#39;s3-\u0026gt;s5\u0026#39;,\u0026#39;s4-\u0026gt;s5\u0026#39;,\u0026#39;s4-\u0026gt;s3\u0026#39;,\u0026#39;s4-\u0026gt;s4\u0026#39;,\u0026#39;s4-\u0026gt;s2\u0026#39;] #状态转移概率 P={ \u0026#39;s1-\u0026gt;s1\u0026#39;:1.0, \u0026#39;s1-\u0026gt;s2\u0026#39;:1.0, \u0026#39;s2-\u0026gt;s1\u0026#39;:1.0, \u0026#39;s2-\u0026gt;s3\u0026#39;:1.0, \u0026#39;s3-\u0026gt;s4\u0026#39;:1.0, \u0026#39;s3-\u0026gt;s5\u0026#39;:1.0, \u0026#39;s4-\u0026gt;s5\u0026#39;:1.0, \u0026#39;s4-\u0026gt;s3\u0026#39;:0.2, \u0026#39;s4-\u0026gt;s4\u0026#39;:0.4, \u0026#39;s4-\u0026gt;s2\u0026#39;:0.2, } #奖励函数 rewards={ \u0026#39;s1-\u0026gt;s1\u0026#39;:-1.0, \u0026#39;s1-\u0026gt;s2\u0026#39;:0, \u0026#39;s2-\u0026gt;s1\u0026#39;:-1.0, \u0026#39;s2-\u0026gt;s3\u0026#39;:-2.0, \u0026#39;s3-\u0026gt;s4\u0026#39;:-2.0, \u0026#39;s3-\u0026gt;s5\u0026#39;:0, \u0026#39;s4-\u0026gt;s5\u0026#39;:10, \u0026#39;s4-\u0026gt;s3\u0026#39;:1.0, \u0026#39;s4-\u0026gt;s4\u0026#39;:1.0, \u0026#39;s4-\u0026gt;s2\u0026#39;:1.0, } gamma=0.5 MDP=(state,action,P,rewards,gamma) #策略1 随机策略 Pi_1={ \u0026#39;s1-\u0026gt;s1\u0026#39;:0.5, \u0026#39;s1-\u0026gt;s2\u0026#39;:0.5, \u0026#39;s2-\u0026gt;s1\u0026#39;:0.5, \u0026#39;s2-\u0026gt;s3\u0026#39;:0.5, \u0026#39;s3-\u0026gt;s4\u0026#39;:0.5, \u0026#39;s3-\u0026gt;s5\u0026#39;:0.5, \u0026#39;s4-\u0026gt;s5\u0026#39;:0.5, \u0026#39;s4-s*\u0026#39;:0.5 } #策略2 Pi_2={ \u0026#39;s1-\u0026gt;s1\u0026#39;:0.6, \u0026#39;s1-\u0026gt;s2\u0026#39;:0.4, \u0026#39;s2-\u0026gt;s1\u0026#39;:0.3, \u0026#39;s2-\u0026gt;s3\u0026#39;:0.7, \u0026#39;s3-\u0026gt;s4\u0026#39;:0.5, \u0026#39;s3-\u0026gt;s5\u0026#39;:0.5, \u0026#39;s4-\u0026gt;s5\u0026#39;:0.1, \u0026#39;s4-\u0026gt;s*\u0026#39;:0.9 } 如何计算MDP下，一个策略$\\pi$的状态价值函数\nMDP-\u0026gt;MRP\n奖励函数 $$ r^\\prime(s)=\\sum_{a \\in \\mathcal{A}}\\pi(a \\mid s)r(s,a) $$\n状态转移 $$ P^\\prime(s^\\prime|s)=\\sum_{a \\in \\mathcal{A}}{\\pi(a \\mid s)P(s^\\prime \\mid s,a)} $$\nMonte Carlo $$ V^\\pi(s)=\\mathbb{E}\\pi\\left[G_t \\mid S_t=s\\right] \\approx \\frac{1}{N} \\sum{i=1}^N G_t^{(i)} $$\n步骤:\n使用策略 $\\pi$ 采样若干条序列: $$ s_0^{(i)} \\stackrel{a_0^{(i)}}{\\longrightarrow} r_0^{(i)}, s_1^{(i)} \\stackrel{a_1^{(i)}}{\\longrightarrow} r_1^{(i)}, s_2^{(i)} \\stackrel{a_2^{(i)}}{\\longrightarrow} \\cdots \\stackrel{a_{T-1}^{(i)}}{\\longrightarrow} r_{T-1}^{(i)}, s_T^{(i)} $$ 对每一条序列中的每一时间步 $t$ 的状态 $s$ 进行以下操作: 更新状态 $s$ 的计数器 $N(s) \\leftarrow N(s)+1$; 更新状态 $s$ 的总回报 $M(s) \\leftarrow M(s)+G_t$ ； 每一个状态的价值被估计为回报的平均值 $V(s)=M(s) / N(s)$ 。 根据大数定律，当 $N(s) \\rightarrow \\infty$ ，有 $V(s) \\rightarrow V^\\pi(s)$ 。计算回报的期望时，除了可以把所有的回报加起来除以次数，还有一种增量更新的方法。对于每个状态 $s$ 和对应回报$G$ ，进行如下计算: $N(s) \\leftarrow N(s)+1$ $V(s) \\leftarrow V(s)+\\frac{1}{N(s)}(G-V(S))$ import numpy as np S = [\u0026#34;s1\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;] # 状态集合 A = [\u0026#34;保持s1\u0026#34;, \u0026#34;前往s1\u0026#34;, \u0026#34;前往s2\u0026#34;, \u0026#34;前往s3\u0026#34;, \u0026#34;前往s4\u0026#34;, \u0026#34;前往s5\u0026#34;, \u0026#34;概率前往\u0026#34;] # 动作集合 # 状态转移函数 P = { \u0026#34;s1-保持s1-s1\u0026#34;: 1.0, \u0026#34;s1-前往s2-s2\u0026#34;: 1.0, \u0026#34;s2-前往s1-s1\u0026#34;: 1.0, \u0026#34;s2-前往s3-s3\u0026#34;: 1.0, \u0026#34;s3-前往s4-s4\u0026#34;: 1.0, \u0026#34;s3-前往s5-s5\u0026#34;: 1.0, \u0026#34;s4-前往s5-s5\u0026#34;: 1.0, \u0026#34;s4-概率前往-s2\u0026#34;: 0.2, \u0026#34;s4-概率前往-s3\u0026#34;: 0.4, \u0026#34;s4-概率前往-s4\u0026#34;: 0.4, } # 奖励函数 R = { \u0026#34;s1-保持s1\u0026#34;: -1, \u0026#34;s1-前往s2\u0026#34;: 0, \u0026#34;s2-前往s1\u0026#34;: -1, \u0026#34;s2-前往s3\u0026#34;: -2, \u0026#34;s3-前往s4\u0026#34;: -2, \u0026#34;s3-前往s5\u0026#34;: 0, \u0026#34;s4-前往s5\u0026#34;: 10, \u0026#34;s4-概率前往\u0026#34;: 1, } gamma = 0.5 # 折扣因子 MDP = (S, A, P, R, gamma) # 策略1,随机策略 Pi_1 = { \u0026#34;s1-保持s1\u0026#34;: 0.5, \u0026#34;s1-前往s2\u0026#34;: 0.5, \u0026#34;s2-前往s1\u0026#34;: 0.5, \u0026#34;s2-前往s3\u0026#34;: 0.5, \u0026#34;s3-前往s4\u0026#34;: 0.5, \u0026#34;s3-前往s5\u0026#34;: 0.5, \u0026#34;s4-前往s5\u0026#34;: 0.5, \u0026#34;s4-概率前往\u0026#34;: 0.5, } # 策略2 Pi_2 = { \u0026#34;s1-保持s1\u0026#34;: 0.6, \u0026#34;s1-前往s2\u0026#34;: 0.4, \u0026#34;s2-前往s1\u0026#34;: 0.3, \u0026#34;s2-前往s3\u0026#34;: 0.7, \u0026#34;s3-前往s4\u0026#34;: 0.5, \u0026#34;s3-前往s5\u0026#34;: 0.5, \u0026#34;s4-前往s5\u0026#34;: 0.1, \u0026#34;s4-概率前往\u0026#34;: 0.9, } # 把输入的两个字符串通过“-”连接,便于使用上述定义的P、R变量 def join(str1, str2): return str1 + \u0026#39;-\u0026#39; + str2 def sample(MDP, Pi, timestep_max, number): \u0026#39;\u0026#39;\u0026#39; 采样函数,策略Pi,限制最长时间步timestep_max,总共采样序列数number \u0026#39;\u0026#39;\u0026#39; S, A, P, R, gamma = MDP episodes = [] for _ in range(number): episode = [] timestep = 0 s = S[np.random.randint(4)] # 随机选择一个除s5以外的状态s作为起点 # 当前状态为终止状态或者时间步太长时,一次采样结束 while s != \u0026#34;s5\u0026#34; and timestep \u0026lt;= timestep_max: timestep += 1 rand, temp = np.random.rand(), 0 # 在状态s下根据策略选择动作 for a_opt in A: temp += Pi.get(join(s, a_opt), 0) if temp \u0026gt; rand: a = a_opt r = R.get(join(s, a), 0) break rand, temp = np.random.rand(), 0 # 根据状态转移概率得到下一个状态s_next for s_opt in S: temp += P.get(join(join(s, a), s_opt), 0) if temp \u0026gt; rand: s_next = s_opt break episode.append((s, a, r, s_next)) # 把（s,a,r,s_next）元组放入序列中 s = s_next # s_next变成当前状态,开始接下来的循环 episodes.append(episode) return episodes # # 采样5次,每个序列最长不超过20步 # episodes = sample(MDP, Pi_1, 20, 5)#策略为Pi_1 # 对所有采样序列计算所有状态的价值 def MC(episodes, V, N, gamma): for episode in episodes: G = 0 for i in range(len(episode) - 1, -1, -1): #一个序列从后往前计算 (s, a, r, s_next) = episode[i] G = r + gamma * G N[s] = N[s] + 1 V[s] = V[s] + (G - V[s]) / N[s] timestep_max = 20 # 采样1000次,可以自行修改 episodes = sample(MDP, Pi_1, timestep_max, 1000) gamma = 0.5 V = {\u0026#34;s1\u0026#34;: 0, \u0026#34;s2\u0026#34;: 0, \u0026#34;s3\u0026#34;: 0, \u0026#34;s4\u0026#34;: 0, \u0026#34;s5\u0026#34;: 0} N = {\u0026#34;s1\u0026#34;: 0, \u0026#34;s2\u0026#34;: 0, \u0026#34;s3\u0026#34;: 0, \u0026#34;s4\u0026#34;: 0, \u0026#34;s5\u0026#34;: 0} MC(episodes, V, N, gamma) print(\u0026#34;使用蒙特卡洛方法计算MDP的状态价值为\\n\u0026#34;, V) 最优策略 对于任意的状态 $s$ 都有 $V^\\pi(s) \\geq V^{\\pi^{\\prime}}(s)$ ，记 $\\pi\u0026gt;\\pi^{\\prime}$ 。\n于是在有限状态 和动作集合的 MDP 中，至少存在一个策略比其他所有策略都好或者 至少存在一个策略不差于其他所有策略，这个策略就是最优策略 (optimal policy) 。最优策略可能有很多个，我们都将其表示为 $\\pi^(s)$ 最优策略都有相同的状态价值函数，我们称之为最优状态价值函数， 表示为: $$ V^(s)=\\max \\pi V^\\pi(s), \\quad \\forall s \\in \\mathcal{S} $$ 同理，我们定义最优动作价值函数: $$ Q^(s, a)=\\max _\\pi Q^\\pi(s, a), \\quad \\forall s \\in \\mathcal{S}, a \\in \\mathcal{A} $$ 最优状态价值函数和最优动作价值函数之间的关系： $$ Q^(s, a)=r(s,a)+\\gamma\\sum{s^\\prime \\in S}P(s^\\prime \\mid s,a)V^(s^\\prime) $$ 最优状态价值是选择此时使最优动作价值最大的那一个动作时的状态价值 $$ V^(s)=\\max_{a \\in \\mathcal{A}}Q^*(s,a) $$\nBellman最优方程 根据 $V^(s)$ 和 $Q^(s, a)$ 的关系，我们可以得到贝尔曼最优方程 (Bellman optimality equation) : $$ \\begin{gathered} V^(s)=\\max {a \\in \\mathcal{A}}\\left{r(s, a)+\\gamma \\sum{s^{\\prime} \\in \\mathcal{S}} p\\left(s^{\\prime} \\mid s, a\\right) V^\\left(s^{\\prime}\\right)\\right} \\ Q^(s, a)=r(s, a)+\\gamma \\sum_{s^{\\prime} \\in \\mathcal{S}} p\\left(s^{\\prime} \\mid s, a\\right) \\max _{a^{\\prime} \\in \\mathcal{A}} Q^\\left(s^{\\prime}, a^{\\prime}\\right) \\end{gathered} $$\nDP优化 基于动态规划的强化学习算法主要有两种一是策略迭代,二是价值迭代\n策略迭代:策略评估(使用贝尔曼期望方程-\u0026gt;策略的状态价值函数)+策略提升\n策略迭代算法 $$ \\begin{aligned} V^\\pi(s) \u0026amp; =\\mathbb{E}\\pi\\left[R_t+\\gamma V^\\pi\\left(S{t+1}\\right) \\mid S_t=s\\right] \\ \u0026amp; =\\sum_{a \\in A} \\pi(a \\mid s)\\left(r(s, a)+\\gamma \\sum_{s^{\\prime} \\in S} p\\left(s^{\\prime} \\mid s, a\\right) V^\\pi\\left(s^{\\prime}\\right)\\right) \\ \\end{aligned} $$\nDQN DDPG 参考文献 https://www.jianshu.com/p/1765772c8444\n","permalink":"https://niceasiv.cn/posts/reinforment_learning/","summary":"基础 马尔科夫决策(MDP) 在随机过程中某时刻$t$的状态用$S_t$表示，所以可能的状态组成了状态空间$S$。\n如果已知历史的状态信息即$(S_1,\u0026hellip;,S_t)$,那么下一个时刻状态为$S_{t+1}$的概率为$P(S_{t+1}\\mid S_1,\u0026hellip;,S_t)$\n当且仅当某时刻的状态只取决于上一时刻的状态时，一个随机过程被称为具有马尔可夫性质\n$$ P(S_{t+1}\\mid S_t)=P(S_{t+1}\\mid S_1,\u0026hellip;,S_t) $$ 也就是说当前状态是未来的充分统计量，即下一个状态只取决于当前状态，而不会受到过去状态的影响。\n注意：\n虽然$t+1$时刻的状态只与$t$时刻的状态有关，但是$t$时刻的状态其实包含了$t-1$时刻的状态的信息，通过这种链式的关系，历史的信息被传递到了现在。\nMarkov process 通常用两元组$\u0026lt;S,P\u0026gt;$描述一个马尔科夫过程，其中$S$是有限状态集合，$P$是状态转移矩阵\n矩阵$P$中第$i$行第$j$列$P(s_j|s_i)$表示状态$s_i$转移到状态$s_j$的概率，从某个状态出发，到达其他状态的概率和必须为1，即状态转移矩阵的每一行的和为1。\n给定一个马尔可夫过程，我们就可以从某个状态出发，根据它的状态转移矩阵生成一个状态序列（episode），这个步骤也被叫做采样（sampling）。\nMarkov reward process(MRP) 一个马尔科夫奖励过程由$\\langle \\mathcal{S},\\mathcal{P},r,\\gamma \\rangle$\n$\\mathcal{S}$ 是有限状态的集合。 $\\mathcal{P}$ 是状态转移矩阵。 $r$是奖励函数,某个状态$s$的奖励$r(s)$指转移到该状态时可以获得奖励的期望。 $\\gamma$ 是折扣因子,$\\gamma$的取值为$[0,1)$ 。引入折扣因子的理由为远期利益具有一定不确定性，有时我们更希望能够尽快获得一些奖励，所以我们需要对远期利益打一些折扣。接近 1 的 $\\gamma$ 更关注长期的累计奖励，接近0的$\\gamma$ 更考虑短期奖励。 奖励函数的本质:向智能体传达目标(MDP) 强化学习的标准交互过程如下：每个时刻，智能体根据根据其 策略(policy)，在当前所处 状态(state) 选择一个 动作(action)，环境(environment) 对这些动作做出相应的相应的响应，转移到新状态，同时产生一个 奖励信号 (reward)，这通常是一个数值，奖励的折扣累加和称为 收益/回报 (return)，是智能体在动作选择过程中想要最大化的目标\n“奖励 \u0026amp; 收益” 其实是智能体目标的一种形式化、数值化的表征。可以把这种想法非正式地表述为 “收益假设” 收益是通过奖励信号计算的，而奖励函数是我们提供的，奖励函数起到了人与算法沟通的桥梁作用 需要注意的是，智能体只会学习如何最大化收益，如果想让它完成某些指定任务，就必须保证我们设计的奖励函数可以使得智能体最大化收益的同时也能实现我们的目标 回报 在一个马尔可夫奖励过程中，从第$t$时刻状态$S_t$开始，直到终止状态时，所有奖励的衰减之和称为回报（Return）\n假设设置$\\gamma =0.5$\n$$ G_t=R_t+\\gamma R_{t+1}+\\gamma^2 R_{t+2}+\\cdots=\\sum_{k=0}^{\\infty} \\gamma^k R_{t+k} $$ 假设路径为1,2,3,6\nimport numpy as np np.random.seed(0) #概率转移矩阵 P=[ [0.9,0.1,0.0,0.0,0.0,0.0], [0.5,0.0,0.5,0.0,0.0,0.0], [0.0,0.0,0.0,0.6,0.0,0.4], [0.0,0.0,0.0,0.0,0.3,0.7], [0.0,0.2,0.3,0.5,0.0,0.0], [0.0,0.0,0.0,0.6,0.0,1.0], ] P=np.array(P) rewards=[-1,-2,-2,10,1,0] gamma=0.5 def compute_chain_reward(start_index,chain,gamma): reward=0 for i in range(len(chain)): reward=gamma*reward+rewards[chain[i]-1] return reward chain=[1,2,3,6] start_index=0 reward=compute_chain_reward(start_index,chain,gamma) print(reward) 状态价值函数 一个状态的期望回报(即从这个状态出发的未来累积奖励的期望)-\u0026gt;价值\n即其状态价值函数$V_{\\pi}(s)$就等于转移到每个通路上的概率（由策略决定）乘以每条路上得到的回报即\n$V(s)=\\mathbb{E}\\left[G_t \\mid S_t=s\\right]$\n展开为: $$ \\begin{align} V(s) \u0026amp;=\\mathbb{E}[G_t \\mid S_t=s] \\ \u0026amp;=\\mathbb{E}[R_t+\\gamma R_{t+1}+\\gamma^2 R_{t+2}+\u0026hellip;\\mid S_t=s]\\ \u0026amp;=\\mathbb{E}[R_t+\\gamma(R_{t+1}+\\gamma R_{t+2})+\u0026hellip; \\mid S_t=s]\\ \u0026amp;=\\mathbb{E}[R_t+\\gamma G_{t+1}\\mid S_t=s]\\ \u0026amp;=\\mathbb{E}[R_t+\\gamma V(S_{t+1})\\mid S_t=s]\\ \\end{align} $$ 一方面,即时奖励的期望正是奖励函数的输出，即：\n$\\mathbb{E}\\left[R_t \\mid S_t=s\\right]=r(s)$\n另一方面，等式中剩余部分 $\\mathbb{E}\\left[\\gamma V\\left(S_{t+1}\\right) \\mid S_t=s\\right]$ 可以根据从状态$s$出发的转移概率得到，即可以得到 $$ V(s)=r(s)+\\gamma\\sum_{s^{\\prime} \\in S }{p(s^{\\prime} \\mid s)V(s^\\prime)} $$ 上式就是马尔可夫奖励过程中非常有名的贝尔曼方程 (Bellman equation)，对每一个状态都成立。","title":"强化学习笔记"}]